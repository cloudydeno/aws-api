// Autogenerated API client for: Amazon EC2 Container Registry

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.115.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export class ECR {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(ECR.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2015-09-21",
    "endpointPrefix": "api.ecr",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceAbbreviation": "Amazon ECR",
    "serviceFullName": "Amazon EC2 Container Registry",
    "serviceId": "ECR",
    "signatureVersion": "v4",
    "signingName": "ecr",
    "targetPrefix": "AmazonEC2ContainerRegistry_V20150921",
    "uid": "ecr-2015-09-21"
  };

  async batchCheckLayerAvailability(
    params: s.BatchCheckLayerAvailabilityRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.BatchCheckLayerAvailabilityResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      layerDigests: params["layerDigests"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "BatchCheckLayerAvailability",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "layers": [toLayer],
        "failures": [toLayerFailure],
      },
    }, await resp.json());
  }

  async batchDeleteImage(
    params: s.BatchDeleteImageRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.BatchDeleteImageResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageIds: params["imageIds"]?.map(x => fromImageIdentifier(x)),
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "BatchDeleteImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "imageIds": [toImageIdentifier],
        "failures": [toImageFailure],
      },
    }, await resp.json());
  }

  async batchGetImage(
    params: s.BatchGetImageRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.BatchGetImageResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageIds: params["imageIds"]?.map(x => fromImageIdentifier(x)),
      acceptedMediaTypes: params["acceptedMediaTypes"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "BatchGetImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "images": [toImage],
        "failures": [toImageFailure],
      },
    }, await resp.json());
  }

  async batchGetRepositoryScanningConfiguration(
    params: s.BatchGetRepositoryScanningConfigurationRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.BatchGetRepositoryScanningConfigurationResponse> {
    const body: jsonP.JSONObject = {
      repositoryNames: params["repositoryNames"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "BatchGetRepositoryScanningConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "scanningConfigurations": [toRepositoryScanningConfiguration],
        "failures": [toRepositoryScanningConfigurationFailure],
      },
    }, await resp.json());
  }

  async completeLayerUpload(
    params: s.CompleteLayerUploadRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.CompleteLayerUploadResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      uploadId: params["uploadId"],
      layerDigests: params["layerDigests"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "CompleteLayerUpload",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "uploadId": "s",
        "layerDigest": "s",
      },
    }, await resp.json());
  }

  async createPullThroughCacheRule(
    params: s.CreatePullThroughCacheRuleRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.CreatePullThroughCacheRuleResponse> {
    const body: jsonP.JSONObject = {
      ecrRepositoryPrefix: params["ecrRepositoryPrefix"],
      upstreamRegistryUrl: params["upstreamRegistryUrl"],
      registryId: params["registryId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "CreatePullThroughCacheRule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ecrRepositoryPrefix": "s",
        "upstreamRegistryUrl": "s",
        "createdAt": "d",
        "registryId": "s",
      },
    }, await resp.json());
  }

  async createRepository(
    params: s.CreateRepositoryRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.CreateRepositoryResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      tags: params["tags"]?.map(x => fromTag(x)),
      imageTagMutability: params["imageTagMutability"],
      imageScanningConfiguration: fromImageScanningConfiguration(params["imageScanningConfiguration"]),
      encryptionConfiguration: fromEncryptionConfiguration(params["encryptionConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "CreateRepository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repository": toRepository,
      },
    }, await resp.json());
  }

  async deleteLifecyclePolicy(
    params: s.DeleteLifecyclePolicyRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.DeleteLifecyclePolicyResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DeleteLifecyclePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "lifecyclePolicyText": "s",
        "lastEvaluatedAt": "d",
      },
    }, await resp.json());
  }

  async deletePullThroughCacheRule(
    params: s.DeletePullThroughCacheRuleRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.DeletePullThroughCacheRuleResponse> {
    const body: jsonP.JSONObject = {
      ecrRepositoryPrefix: params["ecrRepositoryPrefix"],
      registryId: params["registryId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DeletePullThroughCacheRule",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ecrRepositoryPrefix": "s",
        "upstreamRegistryUrl": "s",
        "createdAt": "d",
        "registryId": "s",
      },
    }, await resp.json());
  }

  async deleteRegistryPolicy(
    opts: client.RequestOptions = {},
  ): Promise<s.DeleteRegistryPolicyResponse> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DeleteRegistryPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "policyText": "s",
      },
    }, await resp.json());
  }

  async deleteRepository(
    params: s.DeleteRepositoryRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.DeleteRepositoryResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      force: params["force"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DeleteRepository",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repository": toRepository,
      },
    }, await resp.json());
  }

  async deleteRepositoryPolicy(
    params: s.DeleteRepositoryPolicyRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.DeleteRepositoryPolicyResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DeleteRepositoryPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "policyText": "s",
      },
    }, await resp.json());
  }

  async describeImageReplicationStatus(
    params: s.DescribeImageReplicationStatusRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.DescribeImageReplicationStatusResponse> {
    const body: jsonP.JSONObject = {
      repositoryName: params["repositoryName"],
      imageId: fromImageIdentifier(params["imageId"]),
      registryId: params["registryId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DescribeImageReplicationStatus",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositoryName": "s",
        "imageId": toImageIdentifier,
        "replicationStatuses": [toImageReplicationStatus],
      },
    }, await resp.json());
  }

  async describeImageScanFindings(
    params: s.DescribeImageScanFindingsRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.DescribeImageScanFindingsResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageId: fromImageIdentifier(params["imageId"]),
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DescribeImageScanFindings",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "imageId": toImageIdentifier,
        "imageScanStatus": toImageScanStatus,
        "imageScanFindings": toImageScanFindings,
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeImages(
    params: s.DescribeImagesRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.DescribeImagesResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageIds: params["imageIds"]?.map(x => fromImageIdentifier(x)),
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filter: fromDescribeImagesFilter(params["filter"]),
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DescribeImages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "imageDetails": [toImageDetail],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describePullThroughCacheRules(
    params: s.DescribePullThroughCacheRulesRequest = {},
    opts: client.RequestOptions = {},
  ): Promise<s.DescribePullThroughCacheRulesResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      ecrRepositoryPrefixes: params["ecrRepositoryPrefixes"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DescribePullThroughCacheRules",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "pullThroughCacheRules": [toPullThroughCacheRule],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async describeRegistry(
    opts: client.RequestOptions = {},
  ): Promise<s.DescribeRegistryResponse> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DescribeRegistry",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "replicationConfiguration": toReplicationConfiguration,
      },
    }, await resp.json());
  }

  async describeRepositories(
    params: s.DescribeRepositoriesRequest = {},
    opts: client.RequestOptions = {},
  ): Promise<s.DescribeRepositoriesResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryNames: params["repositoryNames"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DescribeRepositories",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "repositories": [toRepository],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async getAuthorizationToken(
    params: s.GetAuthorizationTokenRequest = {},
    opts: client.RequestOptions = {},
  ): Promise<s.GetAuthorizationTokenResponse> {
    const body: jsonP.JSONObject = {
      registryIds: params["registryIds"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GetAuthorizationToken",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "authorizationData": [toAuthorizationData],
      },
    }, await resp.json());
  }

  async getDownloadUrlForLayer(
    params: s.GetDownloadUrlForLayerRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.GetDownloadUrlForLayerResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      layerDigest: params["layerDigest"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GetDownloadUrlForLayer",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "downloadUrl": "s",
        "layerDigest": "s",
      },
    }, await resp.json());
  }

  async getLifecyclePolicy(
    params: s.GetLifecyclePolicyRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.GetLifecyclePolicyResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GetLifecyclePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "lifecyclePolicyText": "s",
        "lastEvaluatedAt": "d",
      },
    }, await resp.json());
  }

  async getLifecyclePolicyPreview(
    params: s.GetLifecyclePolicyPreviewRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.GetLifecyclePolicyPreviewResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageIds: params["imageIds"]?.map(x => fromImageIdentifier(x)),
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filter: fromLifecyclePolicyPreviewFilter(params["filter"]),
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GetLifecyclePolicyPreview",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "lifecyclePolicyText": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.LifecyclePolicyPreviewStatus>(x),
        "nextToken": "s",
        "previewResults": [toLifecyclePolicyPreviewResult],
        "summary": toLifecyclePolicyPreviewSummary,
      },
    }, await resp.json());
  }

  async getRegistryPolicy(
    opts: client.RequestOptions = {},
  ): Promise<s.GetRegistryPolicyResponse> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GetRegistryPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "policyText": "s",
      },
    }, await resp.json());
  }

  async getRegistryScanningConfiguration(
    opts: client.RequestOptions = {},
  ): Promise<s.GetRegistryScanningConfigurationResponse> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GetRegistryScanningConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "scanningConfiguration": toRegistryScanningConfiguration,
      },
    }, await resp.json());
  }

  async getRepositoryPolicy(
    params: s.GetRepositoryPolicyRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.GetRepositoryPolicyResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GetRepositoryPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "policyText": "s",
      },
    }, await resp.json());
  }

  async initiateLayerUpload(
    params: s.InitiateLayerUploadRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.InitiateLayerUploadResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "InitiateLayerUpload",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "uploadId": "s",
        "partSize": "n",
      },
    }, await resp.json());
  }

  async listImages(
    params: s.ListImagesRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.ListImagesResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      nextToken: params["nextToken"],
      maxResults: params["maxResults"],
      filter: fromListImagesFilter(params["filter"]),
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ListImages",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "imageIds": [toImageIdentifier],
        "nextToken": "s",
      },
    }, await resp.json());
  }

  async listTagsForResource(
    params: s.ListTagsForResourceRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.ListTagsForResourceResponse> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ListTagsForResource",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "tags": [toTag],
      },
    }, await resp.json());
  }

  async putImage(
    params: s.PutImageRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.PutImageResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageManifest: params["imageManifest"],
      imageManifestMediaType: params["imageManifestMediaType"],
      imageTag: params["imageTag"],
      imageDigest: params["imageDigest"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "PutImage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "image": toImage,
      },
    }, await resp.json());
  }

  async putImageScanningConfiguration(
    params: s.PutImageScanningConfigurationRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.PutImageScanningConfigurationResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageScanningConfiguration: fromImageScanningConfiguration(params["imageScanningConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "PutImageScanningConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "imageScanningConfiguration": toImageScanningConfiguration,
      },
    }, await resp.json());
  }

  async putImageTagMutability(
    params: s.PutImageTagMutabilityRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.PutImageTagMutabilityResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageTagMutability: params["imageTagMutability"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "PutImageTagMutability",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "imageTagMutability": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageTagMutability>(x),
      },
    }, await resp.json());
  }

  async putLifecyclePolicy(
    params: s.PutLifecyclePolicyRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.PutLifecyclePolicyResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      lifecyclePolicyText: params["lifecyclePolicyText"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "PutLifecyclePolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "lifecyclePolicyText": "s",
      },
    }, await resp.json());
  }

  async putRegistryPolicy(
    params: s.PutRegistryPolicyRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.PutRegistryPolicyResponse> {
    const body: jsonP.JSONObject = {
      policyText: params["policyText"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "PutRegistryPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "policyText": "s",
      },
    }, await resp.json());
  }

  async putRegistryScanningConfiguration(
    params: s.PutRegistryScanningConfigurationRequest = {},
    opts: client.RequestOptions = {},
  ): Promise<s.PutRegistryScanningConfigurationResponse> {
    const body: jsonP.JSONObject = {
      scanType: params["scanType"],
      rules: params["rules"]?.map(x => fromRegistryScanningRule(x)),
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "PutRegistryScanningConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryScanningConfiguration": toRegistryScanningConfiguration,
      },
    }, await resp.json());
  }

  async putReplicationConfiguration(
    params: s.PutReplicationConfigurationRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.PutReplicationConfigurationResponse> {
    const body: jsonP.JSONObject = {
      replicationConfiguration: fromReplicationConfiguration(params["replicationConfiguration"]),
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "PutReplicationConfiguration",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "replicationConfiguration": toReplicationConfiguration,
      },
    }, await resp.json());
  }

  async setRepositoryPolicy(
    params: s.SetRepositoryPolicyRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.SetRepositoryPolicyResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      policyText: params["policyText"],
      force: params["force"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "SetRepositoryPolicy",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "policyText": "s",
      },
    }, await resp.json());
  }

  async startImageScan(
    params: s.StartImageScanRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.StartImageScanResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      imageId: fromImageIdentifier(params["imageId"]),
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "StartImageScan",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "imageId": toImageIdentifier,
        "imageScanStatus": toImageScanStatus,
      },
    }, await resp.json());
  }

  async startLifecyclePolicyPreview(
    params: s.StartLifecyclePolicyPreviewRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.StartLifecyclePolicyPreviewResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      lifecyclePolicyText: params["lifecyclePolicyText"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "StartLifecyclePolicyPreview",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "lifecyclePolicyText": "s",
        "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.LifecyclePolicyPreviewStatus>(x),
      },
    }, await resp.json());
  }

  async tagResource(
    params: s.TagResourceRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tags: params["tags"]?.map(x => fromTag(x)),
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "TagResource",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async untagResource(
    params: s.UntagResourceRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      resourceArn: params["resourceArn"],
      tagKeys: params["tagKeys"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "UntagResource",
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async uploadLayerPart(
    params: s.UploadLayerPartRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.UploadLayerPartResponse> {
    const body: jsonP.JSONObject = {
      registryId: params["registryId"],
      repositoryName: params["repositoryName"],
      uploadId: params["uploadId"],
      partFirstByte: params["partFirstByte"],
      partLastByte: params["partLastByte"],
      layerPartBlob: serializeBlob(params["layerPartBlob"]),
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "UploadLayerPart",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "registryId": "s",
        "repositoryName": "s",
        "uploadId": "s",
        "lastByteReceived": "n",
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /**
   * Wait until an image scan is complete and findings can be accessed
   * Checks state up to 60 times, 5 seconds apart (about 5 minutes max wait time).
   */
  async waitForImageScanComplete(
    params: s.DescribeImageScanFindingsRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.DescribeImageScanFindingsResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ImageScanComplete';
    for (let i = 0; i < 60; i++) {
      const resp = await this.describeImageScanFindings(params, opts);
      const field = resp?.imageScanStatus?.status;
      if (field === "COMPLETE") return resp;
      if (field === "FAILED") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Wait until a lifecycle policy preview request is complete and results can be accessed
   * Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time).
   */
  async waitForLifecyclePolicyPreviewComplete(
    params: s.GetLifecyclePolicyPreviewRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.GetLifecyclePolicyPreviewResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state LifecyclePolicyPreviewComplete';
    for (let i = 0; i < 20; i++) {
      const resp = await this.getLifecyclePolicyPreview(params, opts);
      const field = resp?.status;
      if (field === "COMPLETE") return resp;
      if (field === "FAILED") throw new Error(errMessage);
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

}

function fromImageIdentifier(input?: s.ImageIdentifier | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    imageDigest: input["imageDigest"],
    imageTag: input["imageTag"],
  }
}
function toImageIdentifier(root: jsonP.JSONValue): s.ImageIdentifier {
  return jsonP.readObj({
    required: {},
    optional: {
      "imageDigest": "s",
      "imageTag": "s",
    },
  }, root);
}

function fromTag(input?: s.Tag | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Key: input["Key"],
    Value: input["Value"],
  }
}
function toTag(root: jsonP.JSONValue): s.Tag {
  return jsonP.readObj({
    required: {},
    optional: {
      "Key": "s",
      "Value": "s",
    },
  }, root);
}

function fromImageScanningConfiguration(input?: s.ImageScanningConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scanOnPush: input["scanOnPush"],
  }
}
function toImageScanningConfiguration(root: jsonP.JSONValue): s.ImageScanningConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "scanOnPush": "b",
    },
  }, root);
}

function fromEncryptionConfiguration(input?: s.EncryptionConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    encryptionType: input["encryptionType"],
    kmsKey: input["kmsKey"],
  }
}
function toEncryptionConfiguration(root: jsonP.JSONValue): s.EncryptionConfiguration {
  return jsonP.readObj({
    required: {
      "encryptionType": (x: jsonP.JSONValue) => cmnP.readEnum<s.EncryptionType>(x),
    },
    optional: {
      "kmsKey": "s",
    },
  }, root);
}

function fromDescribeImagesFilter(input?: s.DescribeImagesFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tagStatus: input["tagStatus"],
  }
}

function fromLifecyclePolicyPreviewFilter(input?: s.LifecyclePolicyPreviewFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tagStatus: input["tagStatus"],
  }
}

function fromListImagesFilter(input?: s.ListImagesFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    tagStatus: input["tagStatus"],
  }
}

function fromRegistryScanningRule(input?: s.RegistryScanningRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    scanFrequency: input["scanFrequency"],
    repositoryFilters: input["repositoryFilters"]?.map(x => fromScanningRepositoryFilter(x)),
  }
}
function toRegistryScanningRule(root: jsonP.JSONValue): s.RegistryScanningRule {
  return jsonP.readObj({
    required: {
      "scanFrequency": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScanFrequency>(x),
      "repositoryFilters": [toScanningRepositoryFilter],
    },
    optional: {},
  }, root);
}

function fromScanningRepositoryFilter(input?: s.ScanningRepositoryFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filter: input["filter"],
    filterType: input["filterType"],
  }
}
function toScanningRepositoryFilter(root: jsonP.JSONValue): s.ScanningRepositoryFilter {
  return jsonP.readObj({
    required: {
      "filter": "s",
      "filterType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScanningRepositoryFilterType>(x),
    },
    optional: {},
  }, root);
}

function fromReplicationConfiguration(input?: s.ReplicationConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    rules: input["rules"]?.map(x => fromReplicationRule(x)),
  }
}
function toReplicationConfiguration(root: jsonP.JSONValue): s.ReplicationConfiguration {
  return jsonP.readObj({
    required: {
      "rules": [toReplicationRule],
    },
    optional: {},
  }, root);
}

function fromReplicationRule(input?: s.ReplicationRule | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    destinations: input["destinations"]?.map(x => fromReplicationDestination(x)),
    repositoryFilters: input["repositoryFilters"]?.map(x => fromRepositoryFilter(x)),
  }
}
function toReplicationRule(root: jsonP.JSONValue): s.ReplicationRule {
  return jsonP.readObj({
    required: {
      "destinations": [toReplicationDestination],
    },
    optional: {
      "repositoryFilters": [toRepositoryFilter],
    },
  }, root);
}

function fromReplicationDestination(input?: s.ReplicationDestination | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    region: input["region"],
    registryId: input["registryId"],
  }
}
function toReplicationDestination(root: jsonP.JSONValue): s.ReplicationDestination {
  return jsonP.readObj({
    required: {
      "region": "s",
      "registryId": "s",
    },
    optional: {},
  }, root);
}

function fromRepositoryFilter(input?: s.RepositoryFilter | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    filter: input["filter"],
    filterType: input["filterType"],
  }
}
function toRepositoryFilter(root: jsonP.JSONValue): s.RepositoryFilter {
  return jsonP.readObj({
    required: {
      "filter": "s",
      "filterType": (x: jsonP.JSONValue) => cmnP.readEnum<s.RepositoryFilterType>(x),
    },
    optional: {},
  }, root);
}

function toLayer(root: jsonP.JSONValue): s.Layer {
  return jsonP.readObj({
    required: {},
    optional: {
      "layerDigest": "s",
      "layerAvailability": (x: jsonP.JSONValue) => cmnP.readEnum<s.LayerAvailability>(x),
      "layerSize": "n",
      "mediaType": "s",
    },
  }, root);
}

function toLayerFailure(root: jsonP.JSONValue): s.LayerFailure {
  return jsonP.readObj({
    required: {},
    optional: {
      "layerDigest": "s",
      "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LayerFailureCode>(x),
      "failureReason": "s",
    },
  }, root);
}

function toImageFailure(root: jsonP.JSONValue): s.ImageFailure {
  return jsonP.readObj({
    required: {},
    optional: {
      "imageId": toImageIdentifier,
      "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageFailureCode>(x),
      "failureReason": "s",
    },
  }, root);
}

function toImage(root: jsonP.JSONValue): s.Image {
  return jsonP.readObj({
    required: {},
    optional: {
      "registryId": "s",
      "repositoryName": "s",
      "imageId": toImageIdentifier,
      "imageManifest": "s",
      "imageManifestMediaType": "s",
    },
  }, root);
}

function toRepositoryScanningConfiguration(root: jsonP.JSONValue): s.RepositoryScanningConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryArn": "s",
      "repositoryName": "s",
      "scanOnPush": "b",
      "scanFrequency": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScanFrequency>(x),
      "appliedScanFilters": [toScanningRepositoryFilter],
    },
  }, root);
}

function toRepositoryScanningConfigurationFailure(root: jsonP.JSONValue): s.RepositoryScanningConfigurationFailure {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryName": "s",
      "failureCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScanningConfigurationFailureCode>(x),
      "failureReason": "s",
    },
  }, root);
}

function toRepository(root: jsonP.JSONValue): s.Repository {
  return jsonP.readObj({
    required: {},
    optional: {
      "repositoryArn": "s",
      "registryId": "s",
      "repositoryName": "s",
      "repositoryUri": "s",
      "createdAt": "d",
      "imageTagMutability": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageTagMutability>(x),
      "imageScanningConfiguration": toImageScanningConfiguration,
      "encryptionConfiguration": toEncryptionConfiguration,
    },
  }, root);
}

function toImageReplicationStatus(root: jsonP.JSONValue): s.ImageReplicationStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "region": "s",
      "registryId": "s",
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ReplicationStatus>(x),
      "failureCode": "s",
    },
  }, root);
}

function toImageScanStatus(root: jsonP.JSONValue): s.ImageScanStatus {
  return jsonP.readObj({
    required: {},
    optional: {
      "status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScanStatus>(x),
      "description": "s",
    },
  }, root);
}

function toImageScanFindings(root: jsonP.JSONValue): s.ImageScanFindings {
  return jsonP.readObj({
    required: {},
    optional: {
      "imageScanCompletedAt": "d",
      "vulnerabilitySourceUpdatedAt": "d",
      "findingSeverityCounts": x => jsonP.readMap(x => cmnP.readEnumReq<s.FindingSeverity>(x), Number, x),
      "findings": [toImageScanFinding],
      "enhancedFindings": [toEnhancedImageScanFinding],
    },
  }, root);
}

function toImageScanFinding(root: jsonP.JSONValue): s.ImageScanFinding {
  return jsonP.readObj({
    required: {},
    optional: {
      "name": "s",
      "description": "s",
      "uri": "s",
      "severity": (x: jsonP.JSONValue) => cmnP.readEnum<s.FindingSeverity>(x),
      "attributes": [toAttribute],
    },
  }, root);
}

function toAttribute(root: jsonP.JSONValue): s.Attribute {
  return jsonP.readObj({
    required: {
      "key": "s",
    },
    optional: {
      "value": "s",
    },
  }, root);
}

function toEnhancedImageScanFinding(root: jsonP.JSONValue): s.EnhancedImageScanFinding {
  return jsonP.readObj({
    required: {},
    optional: {
      "awsAccountId": "s",
      "description": "s",
      "findingArn": "s",
      "firstObservedAt": "d",
      "lastObservedAt": "d",
      "packageVulnerabilityDetails": toPackageVulnerabilityDetails,
      "remediation": toRemediation,
      "resources": [toResource],
      "score": "n",
      "scoreDetails": toScoreDetails,
      "severity": "s",
      "status": "s",
      "title": "s",
      "type": "s",
      "updatedAt": "d",
    },
  }, root);
}

function toPackageVulnerabilityDetails(root: jsonP.JSONValue): s.PackageVulnerabilityDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "cvss": [toCvssScore],
      "referenceUrls": ["s"],
      "relatedVulnerabilities": ["s"],
      "source": "s",
      "sourceUrl": "s",
      "vendorCreatedAt": "d",
      "vendorSeverity": "s",
      "vendorUpdatedAt": "d",
      "vulnerabilityId": "s",
      "vulnerablePackages": [toVulnerablePackage],
    },
  }, root);
}

function toCvssScore(root: jsonP.JSONValue): s.CvssScore {
  return jsonP.readObj({
    required: {},
    optional: {
      "baseScore": "n",
      "scoringVector": "s",
      "source": "s",
      "version": "s",
    },
  }, root);
}

function toVulnerablePackage(root: jsonP.JSONValue): s.VulnerablePackage {
  return jsonP.readObj({
    required: {},
    optional: {
      "arch": "s",
      "epoch": "n",
      "filePath": "s",
      "name": "s",
      "packageManager": "s",
      "release": "s",
      "sourceLayerHash": "s",
      "version": "s",
    },
  }, root);
}

function toRemediation(root: jsonP.JSONValue): s.Remediation {
  return jsonP.readObj({
    required: {},
    optional: {
      "recommendation": toRecommendation,
    },
  }, root);
}

function toRecommendation(root: jsonP.JSONValue): s.Recommendation {
  return jsonP.readObj({
    required: {},
    optional: {
      "url": "s",
      "text": "s",
    },
  }, root);
}

function toResource(root: jsonP.JSONValue): s.Resource {
  return jsonP.readObj({
    required: {},
    optional: {
      "details": toResourceDetails,
      "id": "s",
      "tags": x => jsonP.readMap(String, String, x),
      "type": "s",
    },
  }, root);
}

function toResourceDetails(root: jsonP.JSONValue): s.ResourceDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "awsEcrContainerImage": toAwsEcrContainerImageDetails,
    },
  }, root);
}

function toAwsEcrContainerImageDetails(root: jsonP.JSONValue): s.AwsEcrContainerImageDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "architecture": "s",
      "author": "s",
      "imageHash": "s",
      "imageTags": ["s"],
      "platform": "s",
      "pushedAt": "d",
      "registry": "s",
      "repositoryName": "s",
    },
  }, root);
}

function toScoreDetails(root: jsonP.JSONValue): s.ScoreDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "cvss": toCvssScoreDetails,
    },
  }, root);
}

function toCvssScoreDetails(root: jsonP.JSONValue): s.CvssScoreDetails {
  return jsonP.readObj({
    required: {},
    optional: {
      "adjustments": [toCvssScoreAdjustment],
      "score": "n",
      "scoreSource": "s",
      "scoringVector": "s",
      "version": "s",
    },
  }, root);
}

function toCvssScoreAdjustment(root: jsonP.JSONValue): s.CvssScoreAdjustment {
  return jsonP.readObj({
    required: {},
    optional: {
      "metric": "s",
      "reason": "s",
    },
  }, root);
}

function toImageDetail(root: jsonP.JSONValue): s.ImageDetail {
  return jsonP.readObj({
    required: {},
    optional: {
      "registryId": "s",
      "repositoryName": "s",
      "imageDigest": "s",
      "imageTags": ["s"],
      "imageSizeInBytes": "n",
      "imagePushedAt": "d",
      "imageScanStatus": toImageScanStatus,
      "imageScanFindingsSummary": toImageScanFindingsSummary,
      "imageManifestMediaType": "s",
      "artifactMediaType": "s",
    },
  }, root);
}

function toImageScanFindingsSummary(root: jsonP.JSONValue): s.ImageScanFindingsSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "imageScanCompletedAt": "d",
      "vulnerabilitySourceUpdatedAt": "d",
      "findingSeverityCounts": x => jsonP.readMap(x => cmnP.readEnumReq<s.FindingSeverity>(x), Number, x),
    },
  }, root);
}

function toPullThroughCacheRule(root: jsonP.JSONValue): s.PullThroughCacheRule {
  return jsonP.readObj({
    required: {},
    optional: {
      "ecrRepositoryPrefix": "s",
      "upstreamRegistryUrl": "s",
      "createdAt": "d",
      "registryId": "s",
    },
  }, root);
}

function toAuthorizationData(root: jsonP.JSONValue): s.AuthorizationData {
  return jsonP.readObj({
    required: {},
    optional: {
      "authorizationToken": "s",
      "expiresAt": "d",
      "proxyEndpoint": "s",
    },
  }, root);
}

function toLifecyclePolicyPreviewResult(root: jsonP.JSONValue): s.LifecyclePolicyPreviewResult {
  return jsonP.readObj({
    required: {},
    optional: {
      "imageTags": ["s"],
      "imageDigest": "s",
      "imagePushedAt": "d",
      "action": toLifecyclePolicyRuleAction,
      "appliedRulePriority": "n",
    },
  }, root);
}

function toLifecyclePolicyRuleAction(root: jsonP.JSONValue): s.LifecyclePolicyRuleAction {
  return jsonP.readObj({
    required: {},
    optional: {
      "type": (x: jsonP.JSONValue) => cmnP.readEnum<s.ImageActionType>(x),
    },
  }, root);
}

function toLifecyclePolicyPreviewSummary(root: jsonP.JSONValue): s.LifecyclePolicyPreviewSummary {
  return jsonP.readObj({
    required: {},
    optional: {
      "expiringImageTotalCount": "n",
    },
  }, root);
}

function toRegistryScanningConfiguration(root: jsonP.JSONValue): s.RegistryScanningConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "scanType": (x: jsonP.JSONValue) => cmnP.readEnum<s.ScanType>(x),
      "rules": [toRegistryScanningRule],
    },
  }, root);
}
