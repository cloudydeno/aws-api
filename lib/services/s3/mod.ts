// Autogenerated API client for: Amazon Simple Storage Service

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.105.0/encoding/base64.ts";
import * as HashMd5 from "https://deno.land/std@0.105.0/hash/md5.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";
function hashMD5(data: HashMd5.Message): string {
  const hasher = new HashMd5.Md5();
  hasher.update(data);
  return hasher.toString('base64');
}
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}
function parseBlob(input: string | null | undefined) {
  if (input == null) return input;
  return Base64.decode(input);
}

export class S3 {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(S3.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2006-03-01",
    "checksumFormat": "md5",
    "endpointPrefix": "s3",
    "protocol": "rest-xml",
    "serviceAbbreviation": "Amazon S3",
    "serviceFullName": "Amazon Simple Storage Service",
    "serviceId": "S3",
    "signatureVersion": "s3",
    "uid": "s3-2006-03-01"
  };

  async abortMultipartUpload(
    params: s.AbortMultipartUploadRequest,
  ): Promise<s.AbortMultipartUploadOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("uploadId", params["UploadId"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "AbortMultipartUpload",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
      responseCode: 204,
    });
    return {
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
    };
  }

  async completeMultipartUpload(
    params: s.CompleteMultipartUploadRequest,
  ): Promise<s.CompleteMultipartUploadOutput> {
    const inner = params["MultipartUpload"];
    const body = inner ? xmlP.stringify({
      name: "CompleteMultipartUpload",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        ...(inner["Parts"]?.map(x => ({name: "Part", ...CompletedPart_Serialize(x)})) ?? []),
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("uploadId", params["UploadId"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query, body,
      action: "CompleteMultipartUpload",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Expiration: resp.headers.get("x-amz-expiration"),
      ServerSideEncryption: cmnP.readEnum<s.ServerSideEncryption>(resp.headers.get("x-amz-server-side-encryption")),
      VersionId: resp.headers.get("x-amz-version-id"),
      SSEKMSKeyId: resp.headers.get("x-amz-server-side-encryption-aws-kms-key-id"),
      BucketKeyEnabled: cmnP.readBool(resp.headers.get("x-amz-server-side-encryption-bucket-key-enabled")),
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
      ...xml.strings({
        optional: {"Location":true,"Bucket":true,"Key":true,"ETag":true},
      }),
    };
  }

  async copyObject(
    params: s.CopyObjectRequest,
  ): Promise<s.CopyObjectOutput> {
    const headers = new Headers;
    if (params["ACL"] != null) headers.append("x-amz-acl", params["ACL"]);
    if (params["CacheControl"] != null) headers.append("Cache-Control", params["CacheControl"]);
    if (params["ContentDisposition"] != null) headers.append("Content-Disposition", params["ContentDisposition"]);
    if (params["ContentEncoding"] != null) headers.append("Content-Encoding", params["ContentEncoding"]);
    if (params["ContentLanguage"] != null) headers.append("Content-Language", params["ContentLanguage"]);
    if (params["ContentType"] != null) headers.append("Content-Type", params["ContentType"]);
    headers.append("x-amz-copy-source", params["CopySource"]);
    if (params["CopySourceIfMatch"] != null) headers.append("x-amz-copy-source-if-match", params["CopySourceIfMatch"]);
    if (params["CopySourceIfModifiedSince"] != null) headers.append("x-amz-copy-source-if-modified-since", cmnP.serializeDate_rfc822(params["CopySourceIfModifiedSince"]) ?? "");
    if (params["CopySourceIfNoneMatch"] != null) headers.append("x-amz-copy-source-if-none-match", params["CopySourceIfNoneMatch"]);
    if (params["CopySourceIfUnmodifiedSince"] != null) headers.append("x-amz-copy-source-if-unmodified-since", cmnP.serializeDate_rfc822(params["CopySourceIfUnmodifiedSince"]) ?? "");
    if (params["Expires"] != null) headers.append("Expires", cmnP.serializeDate_rfc822(params["Expires"]) ?? "");
    if (params["GrantFullControl"] != null) headers.append("x-amz-grant-full-control", params["GrantFullControl"]);
    if (params["GrantRead"] != null) headers.append("x-amz-grant-read", params["GrantRead"]);
    if (params["GrantReadACP"] != null) headers.append("x-amz-grant-read-acp", params["GrantReadACP"]);
    if (params["GrantWriteACP"] != null) headers.append("x-amz-grant-write-acp", params["GrantWriteACP"]);
    for (const [key, val] of Object.entries(params["Metadata"] ?? {})) {
      headers.append("x-amz-meta-"+key, val ?? "");
    }
    if (params["MetadataDirective"] != null) headers.append("x-amz-metadata-directive", params["MetadataDirective"]);
    if (params["TaggingDirective"] != null) headers.append("x-amz-tagging-directive", params["TaggingDirective"]);
    if (params["ServerSideEncryption"] != null) headers.append("x-amz-server-side-encryption", params["ServerSideEncryption"]);
    if (params["StorageClass"] != null) headers.append("x-amz-storage-class", params["StorageClass"]);
    if (params["WebsiteRedirectLocation"] != null) headers.append("x-amz-website-redirect-location", params["WebsiteRedirectLocation"]);
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSECustomerKey"] != null) headers.append("x-amz-server-side-encryption-customer-key", serializeBlob(params["SSECustomerKey"]) ?? '');
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["SSEKMSKeyId"] != null) headers.append("x-amz-server-side-encryption-aws-kms-key-id", params["SSEKMSKeyId"]);
    if (params["SSEKMSEncryptionContext"] != null) headers.append("x-amz-server-side-encryption-context", params["SSEKMSEncryptionContext"]);
    if (params["BucketKeyEnabled"] != null) headers.append("x-amz-server-side-encryption-bucket-key-enabled", params["BucketKeyEnabled"]?.toString() ?? '');
    if (params["CopySourceSSECustomerAlgorithm"] != null) headers.append("x-amz-copy-source-server-side-encryption-customer-algorithm", params["CopySourceSSECustomerAlgorithm"]);
    if (params["CopySourceSSECustomerKey"] != null) headers.append("x-amz-copy-source-server-side-encryption-customer-key", serializeBlob(params["CopySourceSSECustomerKey"]) ?? '');
    if (params["CopySourceSSECustomerKeyMD5"] != null) headers.append("x-amz-copy-source-server-side-encryption-customer-key-MD5", params["CopySourceSSECustomerKeyMD5"]);
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["Tagging"] != null) headers.append("x-amz-tagging", params["Tagging"]);
    if (params["ObjectLockMode"] != null) headers.append("x-amz-object-lock-mode", params["ObjectLockMode"]);
    if (params["ObjectLockRetainUntilDate"] != null) headers.append("x-amz-object-lock-retain-until-date", cmnP.serializeDate_iso8601(params["ObjectLockRetainUntilDate"]) ?? "");
    if (params["ObjectLockLegalHoldStatus"] != null) headers.append("x-amz-object-lock-legal-hold", params["ObjectLockLegalHoldStatus"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    if (params["ExpectedSourceBucketOwner"] != null) headers.append("x-amz-source-expected-bucket-owner", params["ExpectedSourceBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "CopyObject",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Expiration: resp.headers.get("x-amz-expiration"),
      CopySourceVersionId: resp.headers.get("x-amz-copy-source-version-id"),
      VersionId: resp.headers.get("x-amz-version-id"),
      ServerSideEncryption: cmnP.readEnum<s.ServerSideEncryption>(resp.headers.get("x-amz-server-side-encryption")),
      SSECustomerAlgorithm: resp.headers.get("x-amz-server-side-encryption-customer-algorithm"),
      SSECustomerKeyMD5: resp.headers.get("x-amz-server-side-encryption-customer-key-MD5"),
      SSEKMSKeyId: resp.headers.get("x-amz-server-side-encryption-aws-kms-key-id"),
      SSEKMSEncryptionContext: resp.headers.get("x-amz-server-side-encryption-context"),
      BucketKeyEnabled: cmnP.readBool(resp.headers.get("x-amz-server-side-encryption-bucket-key-enabled")),
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
      CopyObjectResult: {
        ...xml.strings({
          optional: {"ETag":true},
        }),
        LastModified: xml.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
      },
    };
  }

  async createBucket(
    params: s.CreateBucketRequest,
  ): Promise<s.CreateBucketOutput> {
    const inner = params["CreateBucketConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "CreateBucketConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "LocationConstraint", content: inner["LocationConstraint"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["ACL"] != null) headers.append("x-amz-acl", params["ACL"]);
    if (params["GrantFullControl"] != null) headers.append("x-amz-grant-full-control", params["GrantFullControl"]);
    if (params["GrantRead"] != null) headers.append("x-amz-grant-read", params["GrantRead"]);
    if (params["GrantReadACP"] != null) headers.append("x-amz-grant-read-acp", params["GrantReadACP"]);
    if (params["GrantWrite"] != null) headers.append("x-amz-grant-write", params["GrantWrite"]);
    if (params["GrantWriteACP"] != null) headers.append("x-amz-grant-write-acp", params["GrantWriteACP"]);
    if (params["ObjectLockEnabledForBucket"] != null) headers.append("x-amz-bucket-object-lock-enabled", params["ObjectLockEnabledForBucket"]?.toString() ?? '');
    const resp = await this.#client.performRequest({
      headers, body,
      action: "CreateBucket",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}`,
    });
    await resp.arrayBuffer(); // consume body without use
    return {
      Location: resp.headers.get("Location"),
    };
  }

  async createMultipartUpload(
    params: s.CreateMultipartUploadRequest,
  ): Promise<s.CreateMultipartUploadOutput> {
    const headers = new Headers;
    if (params["ACL"] != null) headers.append("x-amz-acl", params["ACL"]);
    if (params["CacheControl"] != null) headers.append("Cache-Control", params["CacheControl"]);
    if (params["ContentDisposition"] != null) headers.append("Content-Disposition", params["ContentDisposition"]);
    if (params["ContentEncoding"] != null) headers.append("Content-Encoding", params["ContentEncoding"]);
    if (params["ContentLanguage"] != null) headers.append("Content-Language", params["ContentLanguage"]);
    if (params["ContentType"] != null) headers.append("Content-Type", params["ContentType"]);
    if (params["Expires"] != null) headers.append("Expires", cmnP.serializeDate_rfc822(params["Expires"]) ?? "");
    if (params["GrantFullControl"] != null) headers.append("x-amz-grant-full-control", params["GrantFullControl"]);
    if (params["GrantRead"] != null) headers.append("x-amz-grant-read", params["GrantRead"]);
    if (params["GrantReadACP"] != null) headers.append("x-amz-grant-read-acp", params["GrantReadACP"]);
    if (params["GrantWriteACP"] != null) headers.append("x-amz-grant-write-acp", params["GrantWriteACP"]);
    for (const [key, val] of Object.entries(params["Metadata"] ?? {})) {
      headers.append("x-amz-meta-"+key, val ?? "");
    }
    if (params["ServerSideEncryption"] != null) headers.append("x-amz-server-side-encryption", params["ServerSideEncryption"]);
    if (params["StorageClass"] != null) headers.append("x-amz-storage-class", params["StorageClass"]);
    if (params["WebsiteRedirectLocation"] != null) headers.append("x-amz-website-redirect-location", params["WebsiteRedirectLocation"]);
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSECustomerKey"] != null) headers.append("x-amz-server-side-encryption-customer-key", serializeBlob(params["SSECustomerKey"]) ?? '');
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["SSEKMSKeyId"] != null) headers.append("x-amz-server-side-encryption-aws-kms-key-id", params["SSEKMSKeyId"]);
    if (params["SSEKMSEncryptionContext"] != null) headers.append("x-amz-server-side-encryption-context", params["SSEKMSEncryptionContext"]);
    if (params["BucketKeyEnabled"] != null) headers.append("x-amz-server-side-encryption-bucket-key-enabled", params["BucketKeyEnabled"]?.toString() ?? '');
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["Tagging"] != null) headers.append("x-amz-tagging", params["Tagging"]);
    if (params["ObjectLockMode"] != null) headers.append("x-amz-object-lock-mode", params["ObjectLockMode"]);
    if (params["ObjectLockRetainUntilDate"] != null) headers.append("x-amz-object-lock-retain-until-date", cmnP.serializeDate_iso8601(params["ObjectLockRetainUntilDate"]) ?? "");
    if (params["ObjectLockLegalHoldStatus"] != null) headers.append("x-amz-object-lock-legal-hold", params["ObjectLockLegalHoldStatus"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "CreateMultipartUpload",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?uploads`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AbortDate: cmnP.readTimestamp(resp.headers.get("x-amz-abort-date")),
      AbortRuleId: resp.headers.get("x-amz-abort-rule-id"),
      ServerSideEncryption: cmnP.readEnum<s.ServerSideEncryption>(resp.headers.get("x-amz-server-side-encryption")),
      SSECustomerAlgorithm: resp.headers.get("x-amz-server-side-encryption-customer-algorithm"),
      SSECustomerKeyMD5: resp.headers.get("x-amz-server-side-encryption-customer-key-MD5"),
      SSEKMSKeyId: resp.headers.get("x-amz-server-side-encryption-aws-kms-key-id"),
      SSEKMSEncryptionContext: resp.headers.get("x-amz-server-side-encryption-context"),
      BucketKeyEnabled: cmnP.readBool(resp.headers.get("x-amz-server-side-encryption-bucket-key-enabled")),
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
      ...xml.strings({
        optional: {"Bucket":true,"Key":true,"UploadId":true},
      }),
    };
  }

  async deleteBucket(
    params: s.DeleteBucketRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "DeleteBucket",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}`,
      responseCode: 204,
    });
  }

  async deleteBucketAnalyticsConfiguration(
    params: s.DeleteBucketAnalyticsConfigurationRequest,
  ): Promise<void> {
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "DeleteBucketAnalyticsConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?analytics`,
      responseCode: 204,
    });
  }

  async deleteBucketCors(
    params: s.DeleteBucketCorsRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "DeleteBucketCors",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?cors`,
      responseCode: 204,
    });
  }

  async deleteBucketEncryption(
    params: s.DeleteBucketEncryptionRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "DeleteBucketEncryption",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?encryption`,
      responseCode: 204,
    });
  }

  async deleteBucketIntelligentTieringConfiguration(
    params: s.DeleteBucketIntelligentTieringConfigurationRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "DeleteBucketIntelligentTieringConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?intelligent-tiering`,
      responseCode: 204,
    });
  }

  async deleteBucketInventoryConfiguration(
    params: s.DeleteBucketInventoryConfigurationRequest,
  ): Promise<void> {
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "DeleteBucketInventoryConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?inventory`,
      responseCode: 204,
    });
  }

  async deleteBucketLifecycle(
    params: s.DeleteBucketLifecycleRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "DeleteBucketLifecycle",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?lifecycle`,
      responseCode: 204,
    });
  }

  async deleteBucketMetricsConfiguration(
    params: s.DeleteBucketMetricsConfigurationRequest,
  ): Promise<void> {
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "DeleteBucketMetricsConfiguration",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?metrics`,
      responseCode: 204,
    });
  }

  async deleteBucketOwnershipControls(
    params: s.DeleteBucketOwnershipControlsRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "DeleteBucketOwnershipControls",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?ownershipControls`,
      responseCode: 204,
    });
  }

  async deleteBucketPolicy(
    params: s.DeleteBucketPolicyRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "DeleteBucketPolicy",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?policy`,
      responseCode: 204,
    });
  }

  async deleteBucketReplication(
    params: s.DeleteBucketReplicationRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "DeleteBucketReplication",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?replication`,
      responseCode: 204,
    });
  }

  async deleteBucketTagging(
    params: s.DeleteBucketTaggingRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "DeleteBucketTagging",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?tagging`,
      responseCode: 204,
    });
  }

  async deleteBucketWebsite(
    params: s.DeleteBucketWebsiteRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "DeleteBucketWebsite",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?website`,
      responseCode: 204,
    });
  }

  async deleteObject(
    params: s.DeleteObjectRequest,
  ): Promise<s.DeleteObjectOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["MFA"] != null) headers.append("x-amz-mfa", params["MFA"]);
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["BypassGovernanceRetention"] != null) headers.append("x-amz-bypass-governance-retention", params["BypassGovernanceRetention"]?.toString() ?? '');
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "DeleteObject",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
      responseCode: 204,
    });
    return {
      DeleteMarker: cmnP.readBool(resp.headers.get("x-amz-delete-marker")),
      VersionId: resp.headers.get("x-amz-version-id"),
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
    };
  }

  async deleteObjectTagging(
    params: s.DeleteObjectTaggingRequest,
  ): Promise<s.DeleteObjectTaggingOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "DeleteObjectTagging",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?tagging`,
      responseCode: 204,
    });
    return {
      VersionId: resp.headers.get("x-amz-version-id"),
    };
  }

  async deleteObjects(
    params: s.DeleteObjectsRequest,
  ): Promise<s.DeleteObjectsOutput> {
    const inner = params["Delete"];
    const body = inner ? xmlP.stringify({
      name: "Delete",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        ...(inner["Objects"]?.map(x => ({name: "Object", ...ObjectIdentifier_Serialize(x)})) ?? []),
        {name: "Quiet", content: inner["Quiet"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["MFA"] != null) headers.append("x-amz-mfa", params["MFA"]);
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["BypassGovernanceRetention"] != null) headers.append("x-amz-bypass-governance-retention", params["BypassGovernanceRetention"]?.toString() ?? '');
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "DeleteObjects",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?delete`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
      ...{
        Deleted: xml.getList("Deleted").map(DeletedObject_Parse),
        Errors: xml.getList("Error").map(Error_Parse),
      },
    };
  }

  async deletePublicAccessBlock(
    params: s.DeletePublicAccessBlockRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "DeletePublicAccessBlock",
      method: "DELETE",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?publicAccessBlock`,
      responseCode: 204,
    });
  }

  async getBucketAccelerateConfiguration(
    params: s.GetBucketAccelerateConfigurationRequest,
  ): Promise<s.GetBucketAccelerateConfigurationOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketAccelerateConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?accelerate`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Status: xml.first("Status", false, x => (x.content ?? '') as s.BucketAccelerateStatus),
    };
  }

  async getBucketAcl(
    params: s.GetBucketAclRequest,
  ): Promise<s.GetBucketAclOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketAcl",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?acl`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Owner: xml.first("Owner", false, Owner_Parse),
      Grants: xml.getList("AccessControlList", "Grant").map(Grant_Parse),
    };
  }

  async getBucketAnalyticsConfiguration(
    params: s.GetBucketAnalyticsConfigurationRequest,
  ): Promise<s.GetBucketAnalyticsConfigurationOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "GetBucketAnalyticsConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?analytics`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AnalyticsConfiguration: AnalyticsConfiguration_Parse(xml),
    };
  }

  async getBucketCors(
    params: s.GetBucketCorsRequest,
  ): Promise<s.GetBucketCorsOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketCors",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?cors`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CORSRules: xml.getList("CORSRule").map(CORSRule_Parse),
    };
  }

  async getBucketEncryption(
    params: s.GetBucketEncryptionRequest,
  ): Promise<s.GetBucketEncryptionOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketEncryption",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?encryption`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ServerSideEncryptionConfiguration: ServerSideEncryptionConfiguration_Parse(xml),
    };
  }

  async getBucketIntelligentTieringConfiguration(
    params: s.GetBucketIntelligentTieringConfigurationRequest,
  ): Promise<s.GetBucketIntelligentTieringConfigurationOutput> {
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "GetBucketIntelligentTieringConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?intelligent-tiering`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      IntelligentTieringConfiguration: IntelligentTieringConfiguration_Parse(xml),
    };
  }

  async getBucketInventoryConfiguration(
    params: s.GetBucketInventoryConfigurationRequest,
  ): Promise<s.GetBucketInventoryConfigurationOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "GetBucketInventoryConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?inventory`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      InventoryConfiguration: InventoryConfiguration_Parse(xml),
    };
  }

  async getBucketLifecycle(
    params: s.GetBucketLifecycleRequest,
  ): Promise<s.GetBucketLifecycleOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketLifecycle",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?lifecycle`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Rules: xml.getList("Rule").map(Rule_Parse),
    };
  }

  async getBucketLifecycleConfiguration(
    params: s.GetBucketLifecycleConfigurationRequest,
  ): Promise<s.GetBucketLifecycleConfigurationOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketLifecycleConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?lifecycle`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Rules: xml.getList("Rule").map(LifecycleRule_Parse),
    };
  }

  async getBucketLocation(
    params: s.GetBucketLocationRequest,
  ): Promise<s.GetBucketLocationOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketLocation",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?location`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LocationConstraint: xml.first("LocationConstraint", false, x => (x.content ?? '') as s.BucketLocationConstraint),
    };
  }

  async getBucketLogging(
    params: s.GetBucketLoggingRequest,
  ): Promise<s.GetBucketLoggingOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketLogging",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?logging`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LoggingEnabled: xml.first("LoggingEnabled", false, LoggingEnabled_Parse),
    };
  }

  async getBucketMetricsConfiguration(
    params: s.GetBucketMetricsConfigurationRequest,
  ): Promise<s.GetBucketMetricsConfigurationOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "GetBucketMetricsConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?metrics`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      MetricsConfiguration: MetricsConfiguration_Parse(xml),
    };
  }

  async getBucketNotification(
    params: s.GetBucketNotificationConfigurationRequest,
  ): Promise<s.NotificationConfigurationDeprecated> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketNotification",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?notification`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TopicConfiguration: xml.first("TopicConfiguration", false, TopicConfigurationDeprecated_Parse),
      QueueConfiguration: xml.first("QueueConfiguration", false, QueueConfigurationDeprecated_Parse),
      CloudFunctionConfiguration: xml.first("CloudFunctionConfiguration", false, CloudFunctionConfiguration_Parse),
    };
  }

  async getBucketNotificationConfiguration(
    params: s.GetBucketNotificationConfigurationRequest,
  ): Promise<s.NotificationConfiguration> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketNotificationConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?notification`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TopicConfigurations: xml.getList("TopicConfiguration").map(TopicConfiguration_Parse),
      QueueConfigurations: xml.getList("QueueConfiguration").map(QueueConfiguration_Parse),
      LambdaFunctionConfigurations: xml.getList("CloudFunctionConfiguration").map(LambdaFunctionConfiguration_Parse),
    };
  }

  async getBucketOwnershipControls(
    params: s.GetBucketOwnershipControlsRequest,
  ): Promise<s.GetBucketOwnershipControlsOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketOwnershipControls",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?ownershipControls`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      OwnershipControls: OwnershipControls_Parse(xml),
    };
  }

  async getBucketPolicy(
    params: s.GetBucketPolicyRequest,
  ): Promise<s.GetBucketPolicyOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?policy`,
    });
    await resp.arrayBuffer(); // consume body without use
    return {
    };
  }

  async getBucketPolicyStatus(
    params: s.GetBucketPolicyStatusRequest,
  ): Promise<s.GetBucketPolicyStatusOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketPolicyStatus",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?policyStatus`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PolicyStatus: {
        IsPublic: xml.first("IsPublic", false, x => x.content === 'true'),
      },
    };
  }

  async getBucketReplication(
    params: s.GetBucketReplicationRequest,
  ): Promise<s.GetBucketReplicationOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketReplication",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?replication`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ReplicationConfiguration: ReplicationConfiguration_Parse(xml),
    };
  }

  async getBucketRequestPayment(
    params: s.GetBucketRequestPaymentRequest,
  ): Promise<s.GetBucketRequestPaymentOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketRequestPayment",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?requestPayment`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Payer: xml.first("Payer", false, x => (x.content ?? '') as s.Payer),
    };
  }

  async getBucketTagging(
    params: s.GetBucketTaggingRequest,
  ): Promise<s.GetBucketTaggingOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketTagging",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?tagging`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TagSet: xml.getList("TagSet", "Tag").map(Tag_Parse),
    };
  }

  async getBucketVersioning(
    params: s.GetBucketVersioningRequest,
  ): Promise<s.GetBucketVersioningOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketVersioning",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?versioning`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Status: xml.first("Status", false, x => (x.content ?? '') as s.BucketVersioningStatus),
      MFADelete: xml.first("MfaDelete", false, x => (x.content ?? '') as s.MFADeleteStatus),
    };
  }

  async getBucketWebsite(
    params: s.GetBucketWebsiteRequest,
  ): Promise<s.GetBucketWebsiteOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetBucketWebsite",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?website`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RedirectAllRequestsTo: xml.first("RedirectAllRequestsTo", false, RedirectAllRequestsTo_Parse),
      IndexDocument: xml.first("IndexDocument", false, IndexDocument_Parse),
      ErrorDocument: xml.first("ErrorDocument", false, ErrorDocument_Parse),
      RoutingRules: xml.getList("RoutingRules", "RoutingRule").map(RoutingRule_Parse),
    };
  }

  async getObject(
    params: s.GetObjectRequest,
  ): Promise<s.GetObjectOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    if (params["IfModifiedSince"] != null) headers.append("If-Modified-Since", cmnP.serializeDate_rfc822(params["IfModifiedSince"]) ?? "");
    if (params["IfNoneMatch"] != null) headers.append("If-None-Match", params["IfNoneMatch"]);
    if (params["IfUnmodifiedSince"] != null) headers.append("If-Unmodified-Since", cmnP.serializeDate_rfc822(params["IfUnmodifiedSince"]) ?? "");
    if (params["Range"] != null) headers.append("Range", params["Range"]);
    if (params["ResponseCacheControl"] != null) query.set("response-cache-control", params["ResponseCacheControl"]?.toString() ?? "");
    if (params["ResponseContentDisposition"] != null) query.set("response-content-disposition", params["ResponseContentDisposition"]?.toString() ?? "");
    if (params["ResponseContentEncoding"] != null) query.set("response-content-encoding", params["ResponseContentEncoding"]?.toString() ?? "");
    if (params["ResponseContentLanguage"] != null) query.set("response-content-language", params["ResponseContentLanguage"]?.toString() ?? "");
    if (params["ResponseContentType"] != null) query.set("response-content-type", params["ResponseContentType"]?.toString() ?? "");
    if (params["ResponseExpires"] != null) query.set("response-expires", cmnP.serializeDate_rfc822(params["ResponseExpires"]) ?? "");
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSECustomerKey"] != null) headers.append("x-amz-server-side-encryption-customer-key", serializeBlob(params["SSECustomerKey"]) ?? '');
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["PartNumber"] != null) query.set("partNumber", params["PartNumber"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "GetObject",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
    });
    return {
      DeleteMarker: cmnP.readBool(resp.headers.get("x-amz-delete-marker")),
      AcceptRanges: resp.headers.get("accept-ranges"),
      Expiration: resp.headers.get("x-amz-expiration"),
      Restore: resp.headers.get("x-amz-restore"),
      LastModified: cmnP.readTimestamp(resp.headers.get("Last-Modified")),
      ContentLength: cmnP.readNum(resp.headers.get("Content-Length")),
      ETag: resp.headers.get("ETag"),
      MissingMeta: cmnP.readNum(resp.headers.get("x-amz-missing-meta")),
      VersionId: resp.headers.get("x-amz-version-id"),
      CacheControl: resp.headers.get("Cache-Control"),
      ContentDisposition: resp.headers.get("Content-Disposition"),
      ContentEncoding: resp.headers.get("Content-Encoding"),
      ContentLanguage: resp.headers.get("Content-Language"),
      ContentRange: resp.headers.get("Content-Range"),
      ContentType: resp.headers.get("Content-Type"),
      Expires: cmnP.readTimestamp(resp.headers.get("Expires")),
      WebsiteRedirectLocation: resp.headers.get("x-amz-website-redirect-location"),
      ServerSideEncryption: cmnP.readEnum<s.ServerSideEncryption>(resp.headers.get("x-amz-server-side-encryption")),
      Metadata: cmnP.toJsObj(resp.headers, "x-amz-meta-", v => v),
      SSECustomerAlgorithm: resp.headers.get("x-amz-server-side-encryption-customer-algorithm"),
      SSECustomerKeyMD5: resp.headers.get("x-amz-server-side-encryption-customer-key-MD5"),
      SSEKMSKeyId: resp.headers.get("x-amz-server-side-encryption-aws-kms-key-id"),
      BucketKeyEnabled: cmnP.readBool(resp.headers.get("x-amz-server-side-encryption-bucket-key-enabled")),
      StorageClass: cmnP.readEnum<s.StorageClass>(resp.headers.get("x-amz-storage-class")),
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
      ReplicationStatus: cmnP.readEnum<s.ReplicationStatus>(resp.headers.get("x-amz-replication-status")),
      PartsCount: cmnP.readNum(resp.headers.get("x-amz-mp-parts-count")),
      TagCount: cmnP.readNum(resp.headers.get("x-amz-tagging-count")),
      ObjectLockMode: cmnP.readEnum<s.ObjectLockMode>(resp.headers.get("x-amz-object-lock-mode")),
      ObjectLockRetainUntilDate: cmnP.readTimestamp(resp.headers.get("x-amz-object-lock-retain-until-date")),
      ObjectLockLegalHoldStatus: cmnP.readEnum<s.ObjectLockLegalHoldStatus>(resp.headers.get("x-amz-object-lock-legal-hold")),
      Body: new Uint8Array(await resp.arrayBuffer()), // TODO: maybe allow proper body streaming,
    };
  }

  async getObjectAcl(
    params: s.GetObjectAclRequest,
  ): Promise<s.GetObjectAclOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "GetObjectAcl",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?acl`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
      ...{
        Owner: xml.first("Owner", false, Owner_Parse),
        Grants: xml.getList("AccessControlList", "Grant").map(Grant_Parse),
      },
    };
  }

  async getObjectLegalHold(
    params: s.GetObjectLegalHoldRequest,
  ): Promise<s.GetObjectLegalHoldOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "GetObjectLegalHold",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?legal-hold`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      LegalHold: ObjectLockLegalHold_Parse(xml),
    };
  }

  async getObjectLockConfiguration(
    params: s.GetObjectLockConfigurationRequest,
  ): Promise<s.GetObjectLockConfigurationOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetObjectLockConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?object-lock`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ObjectLockConfiguration: ObjectLockConfiguration_Parse(xml),
    };
  }

  async getObjectRetention(
    params: s.GetObjectRetentionRequest,
  ): Promise<s.GetObjectRetentionOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "GetObjectRetention",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?retention`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Retention: ObjectLockRetention_Parse(xml),
    };
  }

  async getObjectTagging(
    params: s.GetObjectTaggingRequest,
  ): Promise<s.GetObjectTaggingOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "GetObjectTagging",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?tagging`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      VersionId: resp.headers.get("x-amz-version-id"),
      ...{
        TagSet: xml.getList("TagSet", "Tag").map(Tag_Parse),
      },
    };
  }

  async getObjectTorrent(
    params: s.GetObjectTorrentRequest,
  ): Promise<s.GetObjectTorrentOutput> {
    const headers = new Headers;
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetObjectTorrent",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?torrent`,
    });
    return {
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
      Body: new Uint8Array(await resp.arrayBuffer()), // TODO: maybe allow proper body streaming,
    };
  }

  async getPublicAccessBlock(
    params: s.GetPublicAccessBlockRequest,
  ): Promise<s.GetPublicAccessBlockOutput> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "GetPublicAccessBlock",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?publicAccessBlock`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      PublicAccessBlockConfiguration: PublicAccessBlockConfiguration_Parse(xml),
    };
  }

  async headBucket(
    params: s.HeadBucketRequest,
  ): Promise<void> {
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers,
      action: "HeadBucket",
      method: "HEAD",
      requestUri: cmnP.encodePath`/${params["Bucket"]}`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async headObject(
    params: s.HeadObjectRequest,
  ): Promise<s.HeadObjectOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["IfMatch"] != null) headers.append("If-Match", params["IfMatch"]);
    if (params["IfModifiedSince"] != null) headers.append("If-Modified-Since", cmnP.serializeDate_rfc822(params["IfModifiedSince"]) ?? "");
    if (params["IfNoneMatch"] != null) headers.append("If-None-Match", params["IfNoneMatch"]);
    if (params["IfUnmodifiedSince"] != null) headers.append("If-Unmodified-Since", cmnP.serializeDate_rfc822(params["IfUnmodifiedSince"]) ?? "");
    if (params["Range"] != null) headers.append("Range", params["Range"]);
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSECustomerKey"] != null) headers.append("x-amz-server-side-encryption-customer-key", serializeBlob(params["SSECustomerKey"]) ?? '');
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["PartNumber"] != null) query.set("partNumber", params["PartNumber"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "HeadObject",
      method: "HEAD",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
    });
    await resp.arrayBuffer(); // consume body without use
    return {
      DeleteMarker: cmnP.readBool(resp.headers.get("x-amz-delete-marker")),
      AcceptRanges: resp.headers.get("accept-ranges"),
      Expiration: resp.headers.get("x-amz-expiration"),
      Restore: resp.headers.get("x-amz-restore"),
      ArchiveStatus: cmnP.readEnum<s.ArchiveStatus>(resp.headers.get("x-amz-archive-status")),
      LastModified: cmnP.readTimestamp(resp.headers.get("Last-Modified")),
      ContentLength: cmnP.readNum(resp.headers.get("Content-Length")),
      ETag: resp.headers.get("ETag"),
      MissingMeta: cmnP.readNum(resp.headers.get("x-amz-missing-meta")),
      VersionId: resp.headers.get("x-amz-version-id"),
      CacheControl: resp.headers.get("Cache-Control"),
      ContentDisposition: resp.headers.get("Content-Disposition"),
      ContentEncoding: resp.headers.get("Content-Encoding"),
      ContentLanguage: resp.headers.get("Content-Language"),
      ContentType: resp.headers.get("Content-Type"),
      Expires: cmnP.readTimestamp(resp.headers.get("Expires")),
      WebsiteRedirectLocation: resp.headers.get("x-amz-website-redirect-location"),
      ServerSideEncryption: cmnP.readEnum<s.ServerSideEncryption>(resp.headers.get("x-amz-server-side-encryption")),
      Metadata: cmnP.toJsObj(resp.headers, "x-amz-meta-", v => v),
      SSECustomerAlgorithm: resp.headers.get("x-amz-server-side-encryption-customer-algorithm"),
      SSECustomerKeyMD5: resp.headers.get("x-amz-server-side-encryption-customer-key-MD5"),
      SSEKMSKeyId: resp.headers.get("x-amz-server-side-encryption-aws-kms-key-id"),
      BucketKeyEnabled: cmnP.readBool(resp.headers.get("x-amz-server-side-encryption-bucket-key-enabled")),
      StorageClass: cmnP.readEnum<s.StorageClass>(resp.headers.get("x-amz-storage-class")),
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
      ReplicationStatus: cmnP.readEnum<s.ReplicationStatus>(resp.headers.get("x-amz-replication-status")),
      PartsCount: cmnP.readNum(resp.headers.get("x-amz-mp-parts-count")),
      ObjectLockMode: cmnP.readEnum<s.ObjectLockMode>(resp.headers.get("x-amz-object-lock-mode")),
      ObjectLockRetainUntilDate: cmnP.readTimestamp(resp.headers.get("x-amz-object-lock-retain-until-date")),
      ObjectLockLegalHoldStatus: cmnP.readEnum<s.ObjectLockLegalHoldStatus>(resp.headers.get("x-amz-object-lock-legal-hold")),
    };
  }

  async listBucketAnalyticsConfigurations(
    params: s.ListBucketAnalyticsConfigurationsRequest,
  ): Promise<s.ListBucketAnalyticsConfigurationsOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["ContinuationToken"] != null) query.set("continuation-token", params["ContinuationToken"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "ListBucketAnalyticsConfigurations",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?analytics`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"ContinuationToken":true,"NextContinuationToken":true},
      }),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      AnalyticsConfigurationList: xml.getList("AnalyticsConfiguration").map(AnalyticsConfiguration_Parse),
    };
  }

  async listBucketIntelligentTieringConfigurations(
    params: s.ListBucketIntelligentTieringConfigurationsRequest,
  ): Promise<s.ListBucketIntelligentTieringConfigurationsOutput> {
    const query = new URLSearchParams;
    if (params["ContinuationToken"] != null) query.set("continuation-token", params["ContinuationToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListBucketIntelligentTieringConfigurations",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?intelligent-tiering`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"ContinuationToken":true,"NextContinuationToken":true},
      }),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      IntelligentTieringConfigurationList: xml.getList("IntelligentTieringConfiguration").map(IntelligentTieringConfiguration_Parse),
    };
  }

  async listBucketInventoryConfigurations(
    params: s.ListBucketInventoryConfigurationsRequest,
  ): Promise<s.ListBucketInventoryConfigurationsOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["ContinuationToken"] != null) query.set("continuation-token", params["ContinuationToken"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "ListBucketInventoryConfigurations",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?inventory`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"ContinuationToken":true,"NextContinuationToken":true},
      }),
      InventoryConfigurationList: xml.getList("InventoryConfiguration").map(InventoryConfiguration_Parse),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
    };
  }

  async listBucketMetricsConfigurations(
    params: s.ListBucketMetricsConfigurationsRequest,
  ): Promise<s.ListBucketMetricsConfigurationsOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["ContinuationToken"] != null) query.set("continuation-token", params["ContinuationToken"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "ListBucketMetricsConfigurations",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?metrics`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"ContinuationToken":true,"NextContinuationToken":true},
      }),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      MetricsConfigurationList: xml.getList("MetricsConfiguration").map(MetricsConfiguration_Parse),
    };
  }

  async listBuckets(): Promise<s.ListBucketsOutput> {
    const resp = await this.#client.performRequest({
      action: "ListBuckets",
      method: "GET",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Buckets: xml.getList("Buckets", "Bucket").map(Bucket_Parse),
      Owner: xml.first("Owner", false, Owner_Parse),
    };
  }

  async listMultipartUploads(
    params: s.ListMultipartUploadsRequest,
  ): Promise<s.ListMultipartUploadsOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["Delimiter"] != null) query.set("delimiter", params["Delimiter"]?.toString() ?? "");
    if (params["EncodingType"] != null) query.set("encoding-type", params["EncodingType"]?.toString() ?? "");
    if (params["KeyMarker"] != null) query.set("key-marker", params["KeyMarker"]?.toString() ?? "");
    if (params["MaxUploads"] != null) query.set("max-uploads", params["MaxUploads"]?.toString() ?? "");
    if (params["Prefix"] != null) query.set("prefix", params["Prefix"]?.toString() ?? "");
    if (params["UploadIdMarker"] != null) query.set("upload-id-marker", params["UploadIdMarker"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "ListMultipartUploads",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?uploads`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"Bucket":true,"KeyMarker":true,"UploadIdMarker":true,"NextKeyMarker":true,"Prefix":true,"Delimiter":true,"NextUploadIdMarker":true},
      }),
      MaxUploads: xml.first("MaxUploads", false, x => parseInt(x.content ?? '0')),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      Uploads: xml.getList("Upload").map(MultipartUpload_Parse),
      CommonPrefixes: xml.getList("CommonPrefixes").map(CommonPrefix_Parse),
      EncodingType: xml.first("EncodingType", false, x => (x.content ?? '') as s.EncodingType),
    };
  }

  async listObjectVersions(
    params: s.ListObjectVersionsRequest,
  ): Promise<s.ListObjectVersionsOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["Delimiter"] != null) query.set("delimiter", params["Delimiter"]?.toString() ?? "");
    if (params["EncodingType"] != null) query.set("encoding-type", params["EncodingType"]?.toString() ?? "");
    if (params["KeyMarker"] != null) query.set("key-marker", params["KeyMarker"]?.toString() ?? "");
    if (params["MaxKeys"] != null) query.set("max-keys", params["MaxKeys"]?.toString() ?? "");
    if (params["Prefix"] != null) query.set("prefix", params["Prefix"]?.toString() ?? "");
    if (params["VersionIdMarker"] != null) query.set("version-id-marker", params["VersionIdMarker"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "ListObjectVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?versions`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"KeyMarker":true,"VersionIdMarker":true,"NextKeyMarker":true,"NextVersionIdMarker":true,"Name":true,"Prefix":true,"Delimiter":true},
      }),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      Versions: xml.getList("Version").map(ObjectVersion_Parse),
      DeleteMarkers: xml.getList("DeleteMarker").map(DeleteMarkerEntry_Parse),
      MaxKeys: xml.first("MaxKeys", false, x => parseInt(x.content ?? '0')),
      CommonPrefixes: xml.getList("CommonPrefixes").map(CommonPrefix_Parse),
      EncodingType: xml.first("EncodingType", false, x => (x.content ?? '') as s.EncodingType),
    };
  }

  async listObjects(
    params: s.ListObjectsRequest,
  ): Promise<s.ListObjectsOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["Delimiter"] != null) query.set("delimiter", params["Delimiter"]?.toString() ?? "");
    if (params["EncodingType"] != null) query.set("encoding-type", params["EncodingType"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    if (params["MaxKeys"] != null) query.set("max-keys", params["MaxKeys"]?.toString() ?? "");
    if (params["Prefix"] != null) query.set("prefix", params["Prefix"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "ListObjects",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"Marker":true,"NextMarker":true,"Name":true,"Prefix":true,"Delimiter":true},
      }),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      Contents: xml.getList("Contents").map(_Object_Parse),
      MaxKeys: xml.first("MaxKeys", false, x => parseInt(x.content ?? '0')),
      CommonPrefixes: xml.getList("CommonPrefixes").map(CommonPrefix_Parse),
      EncodingType: xml.first("EncodingType", false, x => (x.content ?? '') as s.EncodingType),
    };
  }

  async listObjectsV2(
    params: s.ListObjectsV2Request,
  ): Promise<s.ListObjectsV2Output> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["Delimiter"] != null) query.set("delimiter", params["Delimiter"]?.toString() ?? "");
    if (params["EncodingType"] != null) query.set("encoding-type", params["EncodingType"]?.toString() ?? "");
    if (params["MaxKeys"] != null) query.set("max-keys", params["MaxKeys"]?.toString() ?? "");
    if (params["Prefix"] != null) query.set("prefix", params["Prefix"]?.toString() ?? "");
    if (params["ContinuationToken"] != null) query.set("continuation-token", params["ContinuationToken"]?.toString() ?? "");
    if (params["FetchOwner"] != null) query.set("fetch-owner", params["FetchOwner"]?.toString() ?? "");
    if (params["StartAfter"] != null) query.set("start-after", params["StartAfter"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "ListObjectsV2",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?list-type=2`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"Name":true,"Prefix":true,"Delimiter":true,"ContinuationToken":true,"NextContinuationToken":true,"StartAfter":true},
      }),
      IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
      Contents: xml.getList("Contents").map(_Object_Parse),
      MaxKeys: xml.first("MaxKeys", false, x => parseInt(x.content ?? '0')),
      CommonPrefixes: xml.getList("CommonPrefixes").map(CommonPrefix_Parse),
      EncodingType: xml.first("EncodingType", false, x => (x.content ?? '') as s.EncodingType),
      KeyCount: xml.first("KeyCount", false, x => parseInt(x.content ?? '0')),
    };
  }

  async listParts(
    params: s.ListPartsRequest,
  ): Promise<s.ListPartsOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["MaxParts"] != null) query.set("max-parts", params["MaxParts"]?.toString() ?? "");
    if (params["PartNumberMarker"] != null) query.set("part-number-marker", params["PartNumberMarker"]?.toString() ?? "");
    query.set("uploadId", params["UploadId"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "ListParts",
      method: "GET",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      AbortDate: cmnP.readTimestamp(resp.headers.get("x-amz-abort-date")),
      AbortRuleId: resp.headers.get("x-amz-abort-rule-id"),
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
      ...{
        ...xml.strings({
          optional: {"Bucket":true,"Key":true,"UploadId":true},
        }),
        PartNumberMarker: xml.first("PartNumberMarker", false, x => parseInt(x.content ?? '0')),
        NextPartNumberMarker: xml.first("NextPartNumberMarker", false, x => parseInt(x.content ?? '0')),
        MaxParts: xml.first("MaxParts", false, x => parseInt(x.content ?? '0')),
        IsTruncated: xml.first("IsTruncated", false, x => x.content === 'true'),
        Parts: xml.getList("Part").map(Part_Parse),
        Initiator: xml.first("Initiator", false, Initiator_Parse),
        Owner: xml.first("Owner", false, Owner_Parse),
        StorageClass: xml.first("StorageClass", false, x => (x.content ?? '') as s.StorageClass),
      },
    };
  }

  async putBucketAccelerateConfiguration(
    params: s.PutBucketAccelerateConfigurationRequest,
  ): Promise<void> {
    const inner = params["AccelerateConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "AccelerateConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Status", content: inner["Status"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutBucketAccelerateConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?accelerate`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketAcl(
    params: s.PutBucketAclRequest,
  ): Promise<void> {
    const inner = params["AccessControlPolicy"];
    const body = inner ? xmlP.stringify({
      name: "AccessControlPolicy",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "AccessControlList", children: inner["Grants"]?.map(x => ({name: "Grant", ...Grant_Serialize(x)}))},
        {name: "Owner", ...Owner_Serialize(inner["Owner"])},
      ]}) : "";
    const headers = new Headers;
    if (params["ACL"] != null) headers.append("x-amz-acl", params["ACL"]);
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["GrantFullControl"] != null) headers.append("x-amz-grant-full-control", params["GrantFullControl"]);
    if (params["GrantRead"] != null) headers.append("x-amz-grant-read", params["GrantRead"]);
    if (params["GrantReadACP"] != null) headers.append("x-amz-grant-read-acp", params["GrantReadACP"]);
    if (params["GrantWrite"] != null) headers.append("x-amz-grant-write", params["GrantWrite"]);
    if (params["GrantWriteACP"] != null) headers.append("x-amz-grant-write-acp", params["GrantWriteACP"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutBucketAcl",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?acl`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketAnalyticsConfiguration(
    params: s.PutBucketAnalyticsConfigurationRequest,
  ): Promise<void> {
    const inner = params["AnalyticsConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "AnalyticsConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Id", content: inner["Id"]?.toString()},
        {name: "Filter", ...AnalyticsFilter_Serialize(inner["Filter"])},
        {name: "StorageClassAnalysis", ...StorageClassAnalysis_Serialize(inner["StorageClassAnalysis"])},
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query, body,
      action: "PutBucketAnalyticsConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?analytics`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketCors(
    params: s.PutBucketCorsRequest,
  ): Promise<void> {
    const inner = params["CORSConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "CORSConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        ...(inner["CORSRules"]?.map(x => ({name: "CORSRule", ...CORSRule_Serialize(x)})) ?? []),
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutBucketCors",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?cors`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketEncryption(
    params: s.PutBucketEncryptionRequest,
  ): Promise<void> {
    const inner = params["ServerSideEncryptionConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "ServerSideEncryptionConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        ...(inner["Rules"]?.map(x => ({name: "Rule", ...ServerSideEncryptionRule_Serialize(x)})) ?? []),
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutBucketEncryption",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?encryption`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketIntelligentTieringConfiguration(
    params: s.PutBucketIntelligentTieringConfigurationRequest,
  ): Promise<void> {
    const inner = params["IntelligentTieringConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "IntelligentTieringConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Id", content: inner["Id"]?.toString()},
        {name: "Filter", ...IntelligentTieringFilter_Serialize(inner["Filter"])},
        {name: "Status", content: inner["Status"]?.toString()},
        ...(inner["Tierings"]?.map(x => ({name: "Tiering", ...Tiering_Serialize(x)})) ?? []),
      ]}) : "";
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query, body,
      action: "PutBucketIntelligentTieringConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?intelligent-tiering`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketInventoryConfiguration(
    params: s.PutBucketInventoryConfigurationRequest,
  ): Promise<void> {
    const inner = params["InventoryConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "InventoryConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Destination", ...InventoryDestination_Serialize(inner["Destination"])},
        {name: "IsEnabled", content: inner["IsEnabled"]?.toString()},
        {name: "Filter", ...InventoryFilter_Serialize(inner["Filter"])},
        {name: "Id", content: inner["Id"]?.toString()},
        {name: "IncludedObjectVersions", content: inner["IncludedObjectVersions"]?.toString()},
        {name: "OptionalFields", children: inner["OptionalFields"]?.map(x => ({name: "Field", content: x}))},
        {name: "Schedule", ...InventorySchedule_Serialize(inner["Schedule"])},
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query, body,
      action: "PutBucketInventoryConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?inventory`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketLifecycle(
    params: s.PutBucketLifecycleRequest,
  ): Promise<void> {
    const inner = params["LifecycleConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "LifecycleConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        ...(inner["Rules"]?.map(x => ({name: "Rule", ...Rule_Serialize(x)})) ?? []),
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutBucketLifecycle",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?lifecycle`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketLifecycleConfiguration(
    params: s.PutBucketLifecycleConfigurationRequest,
  ): Promise<void> {
    const inner = params["LifecycleConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "LifecycleConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        ...(inner["Rules"]?.map(x => ({name: "Rule", ...LifecycleRule_Serialize(x)})) ?? []),
      ]}) : "";
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutBucketLifecycleConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?lifecycle`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketLogging(
    params: s.PutBucketLoggingRequest,
  ): Promise<void> {
    const inner = params["BucketLoggingStatus"];
    const body = inner ? xmlP.stringify({
      name: "BucketLoggingStatus",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "LoggingEnabled", ...LoggingEnabled_Serialize(inner["LoggingEnabled"])},
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutBucketLogging",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?logging`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketMetricsConfiguration(
    params: s.PutBucketMetricsConfigurationRequest,
  ): Promise<void> {
    const inner = params["MetricsConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "MetricsConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Id", content: inner["Id"]?.toString()},
        {name: "Filter", ...MetricsFilter_Serialize(inner["Filter"])},
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    query.set("id", params["Id"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query, body,
      action: "PutBucketMetricsConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?metrics`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketNotification(
    params: s.PutBucketNotificationRequest,
  ): Promise<void> {
    const inner = params["NotificationConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "NotificationConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "TopicConfiguration", ...TopicConfigurationDeprecated_Serialize(inner["TopicConfiguration"])},
        {name: "QueueConfiguration", ...QueueConfigurationDeprecated_Serialize(inner["QueueConfiguration"])},
        {name: "CloudFunctionConfiguration", ...CloudFunctionConfiguration_Serialize(inner["CloudFunctionConfiguration"])},
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutBucketNotification",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?notification`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketNotificationConfiguration(
    params: s.PutBucketNotificationConfigurationRequest,
  ): Promise<void> {
    const inner = params["NotificationConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "NotificationConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        ...(inner["TopicConfigurations"]?.map(x => ({name: "TopicConfiguration", ...TopicConfiguration_Serialize(x)})) ?? []),
        ...(inner["QueueConfigurations"]?.map(x => ({name: "QueueConfiguration", ...QueueConfiguration_Serialize(x)})) ?? []),
        ...(inner["LambdaFunctionConfigurations"]?.map(x => ({name: "CloudFunctionConfiguration", ...LambdaFunctionConfiguration_Serialize(x)})) ?? []),
      ]}) : "";
    const headers = new Headers;
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutBucketNotificationConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?notification`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketOwnershipControls(
    params: s.PutBucketOwnershipControlsRequest,
  ): Promise<void> {
    const inner = params["OwnershipControls"];
    const body = inner ? xmlP.stringify({
      name: "OwnershipControls",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        ...(inner["Rules"]?.map(x => ({name: "Rule", ...OwnershipControlsRule_Serialize(x)})) ?? []),
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutBucketOwnershipControls",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?ownershipControls`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketPolicy(
    params: s.PutBucketPolicyRequest,
  ): Promise<void> {
    const body = typeof params["Policy"] === 'string' ? new TextEncoder().encode(params["Policy"]) : params["Policy"];
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ConfirmRemoveSelfBucketAccess"] != null) headers.append("x-amz-confirm-remove-self-bucket-access", params["ConfirmRemoveSelfBucketAccess"]?.toString() ?? '');
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutBucketPolicy",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?policy`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketReplication(
    params: s.PutBucketReplicationRequest,
  ): Promise<void> {
    const inner = params["ReplicationConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "ReplicationConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Role", content: inner["Role"]?.toString()},
        ...(inner["Rules"]?.map(x => ({name: "Rule", ...ReplicationRule_Serialize(x)})) ?? []),
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["Token"] != null) headers.append("x-amz-bucket-object-lock-token", params["Token"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutBucketReplication",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?replication`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketRequestPayment(
    params: s.PutBucketRequestPaymentRequest,
  ): Promise<void> {
    const inner = params["RequestPaymentConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "RequestPaymentConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Payer", content: inner["Payer"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutBucketRequestPayment",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?requestPayment`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketTagging(
    params: s.PutBucketTaggingRequest,
  ): Promise<void> {
    const inner = params["Tagging"];
    const body = inner ? xmlP.stringify({
      name: "Tagging",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "TagSet", children: inner["TagSet"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)}))},
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutBucketTagging",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?tagging`,
      responseCode: 204,
    });
  }

  async putBucketVersioning(
    params: s.PutBucketVersioningRequest,
  ): Promise<void> {
    const inner = params["VersioningConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "VersioningConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "MfaDelete", content: inner["MFADelete"]?.toString()},
        {name: "Status", content: inner["Status"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["MFA"] != null) headers.append("x-amz-mfa", params["MFA"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutBucketVersioning",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?versioning`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putBucketWebsite(
    params: s.PutBucketWebsiteRequest,
  ): Promise<void> {
    const inner = params["WebsiteConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "WebsiteConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "ErrorDocument", ...ErrorDocument_Serialize(inner["ErrorDocument"])},
        {name: "IndexDocument", ...IndexDocument_Serialize(inner["IndexDocument"])},
        {name: "RedirectAllRequestsTo", ...RedirectAllRequestsTo_Serialize(inner["RedirectAllRequestsTo"])},
        {name: "RoutingRules", children: inner["RoutingRules"]?.map(x => ({name: "RoutingRule", ...RoutingRule_Serialize(x)}))},
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutBucketWebsite",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?website`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async putObject(
    params: s.PutObjectRequest,
  ): Promise<s.PutObjectOutput> {
    const body = typeof params["Body"] === 'string' ? new TextEncoder().encode(params["Body"]) : params["Body"];
    const headers = new Headers;
    if (params["ACL"] != null) headers.append("x-amz-acl", params["ACL"]);
    if (params["CacheControl"] != null) headers.append("Cache-Control", params["CacheControl"]);
    if (params["ContentDisposition"] != null) headers.append("Content-Disposition", params["ContentDisposition"]);
    if (params["ContentEncoding"] != null) headers.append("Content-Encoding", params["ContentEncoding"]);
    if (params["ContentLanguage"] != null) headers.append("Content-Language", params["ContentLanguage"]);
    if (params["ContentLength"] != null) headers.append("Content-Length", params["ContentLength"]?.toString() ?? '');
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ContentType"] != null) headers.append("Content-Type", params["ContentType"]);
    if (params["Expires"] != null) headers.append("Expires", cmnP.serializeDate_rfc822(params["Expires"]) ?? "");
    if (params["GrantFullControl"] != null) headers.append("x-amz-grant-full-control", params["GrantFullControl"]);
    if (params["GrantRead"] != null) headers.append("x-amz-grant-read", params["GrantRead"]);
    if (params["GrantReadACP"] != null) headers.append("x-amz-grant-read-acp", params["GrantReadACP"]);
    if (params["GrantWriteACP"] != null) headers.append("x-amz-grant-write-acp", params["GrantWriteACP"]);
    for (const [key, val] of Object.entries(params["Metadata"] ?? {})) {
      headers.append("x-amz-meta-"+key, val ?? "");
    }
    if (params["ServerSideEncryption"] != null) headers.append("x-amz-server-side-encryption", params["ServerSideEncryption"]);
    if (params["StorageClass"] != null) headers.append("x-amz-storage-class", params["StorageClass"]);
    if (params["WebsiteRedirectLocation"] != null) headers.append("x-amz-website-redirect-location", params["WebsiteRedirectLocation"]);
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSECustomerKey"] != null) headers.append("x-amz-server-side-encryption-customer-key", serializeBlob(params["SSECustomerKey"]) ?? '');
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["SSEKMSKeyId"] != null) headers.append("x-amz-server-side-encryption-aws-kms-key-id", params["SSEKMSKeyId"]);
    if (params["SSEKMSEncryptionContext"] != null) headers.append("x-amz-server-side-encryption-context", params["SSEKMSEncryptionContext"]);
    if (params["BucketKeyEnabled"] != null) headers.append("x-amz-server-side-encryption-bucket-key-enabled", params["BucketKeyEnabled"]?.toString() ?? '');
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["Tagging"] != null) headers.append("x-amz-tagging", params["Tagging"]);
    if (params["ObjectLockMode"] != null) headers.append("x-amz-object-lock-mode", params["ObjectLockMode"]);
    if (params["ObjectLockRetainUntilDate"] != null) headers.append("x-amz-object-lock-retain-until-date", cmnP.serializeDate_iso8601(params["ObjectLockRetainUntilDate"]) ?? "");
    if (params["ObjectLockLegalHoldStatus"] != null) headers.append("x-amz-object-lock-legal-hold", params["ObjectLockLegalHoldStatus"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutObject",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
    });
    await resp.arrayBuffer(); // consume body without use
    return {
      Expiration: resp.headers.get("x-amz-expiration"),
      ETag: resp.headers.get("ETag"),
      ServerSideEncryption: cmnP.readEnum<s.ServerSideEncryption>(resp.headers.get("x-amz-server-side-encryption")),
      VersionId: resp.headers.get("x-amz-version-id"),
      SSECustomerAlgorithm: resp.headers.get("x-amz-server-side-encryption-customer-algorithm"),
      SSECustomerKeyMD5: resp.headers.get("x-amz-server-side-encryption-customer-key-MD5"),
      SSEKMSKeyId: resp.headers.get("x-amz-server-side-encryption-aws-kms-key-id"),
      SSEKMSEncryptionContext: resp.headers.get("x-amz-server-side-encryption-context"),
      BucketKeyEnabled: cmnP.readBool(resp.headers.get("x-amz-server-side-encryption-bucket-key-enabled")),
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
    };
  }

  async putObjectAcl(
    params: s.PutObjectAclRequest,
  ): Promise<s.PutObjectAclOutput> {
    const inner = params["AccessControlPolicy"];
    const body = inner ? xmlP.stringify({
      name: "AccessControlPolicy",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "AccessControlList", children: inner["Grants"]?.map(x => ({name: "Grant", ...Grant_Serialize(x)}))},
        {name: "Owner", ...Owner_Serialize(inner["Owner"])},
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["ACL"] != null) headers.append("x-amz-acl", params["ACL"]);
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["GrantFullControl"] != null) headers.append("x-amz-grant-full-control", params["GrantFullControl"]);
    if (params["GrantRead"] != null) headers.append("x-amz-grant-read", params["GrantRead"]);
    if (params["GrantReadACP"] != null) headers.append("x-amz-grant-read-acp", params["GrantReadACP"]);
    if (params["GrantWrite"] != null) headers.append("x-amz-grant-write", params["GrantWrite"]);
    if (params["GrantWriteACP"] != null) headers.append("x-amz-grant-write-acp", params["GrantWriteACP"]);
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query, body,
      action: "PutObjectAcl",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?acl`,
    });
    await resp.arrayBuffer(); // consume body without use
    return {
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
    };
  }

  async putObjectLegalHold(
    params: s.PutObjectLegalHoldRequest,
  ): Promise<s.PutObjectLegalHoldOutput> {
    const inner = params["LegalHold"];
    const body = inner ? xmlP.stringify({
      name: "LegalHold",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Status", content: inner["Status"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query, body,
      action: "PutObjectLegalHold",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?legal-hold`,
    });
    await resp.arrayBuffer(); // consume body without use
    return {
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
    };
  }

  async putObjectLockConfiguration(
    params: s.PutObjectLockConfigurationRequest,
  ): Promise<s.PutObjectLockConfigurationOutput> {
    const inner = params["ObjectLockConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "ObjectLockConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "ObjectLockEnabled", content: inner["ObjectLockEnabled"]?.toString()},
        {name: "Rule", ...ObjectLockRule_Serialize(inner["Rule"])},
      ]}) : "";
    const headers = new Headers;
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["Token"] != null) headers.append("x-amz-bucket-object-lock-token", params["Token"]);
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutObjectLockConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?object-lock`,
    });
    await resp.arrayBuffer(); // consume body without use
    return {
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
    };
  }

  async putObjectRetention(
    params: s.PutObjectRetentionRequest,
  ): Promise<s.PutObjectRetentionOutput> {
    const inner = params["Retention"];
    const body = inner ? xmlP.stringify({
      name: "Retention",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Mode", content: inner["Mode"]?.toString()},
        {name: "RetainUntilDate", content: cmnP.serializeDate_iso8601(inner["RetainUntilDate"])},
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["BypassGovernanceRetention"] != null) headers.append("x-amz-bypass-governance-retention", params["BypassGovernanceRetention"]?.toString() ?? '');
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query, body,
      action: "PutObjectRetention",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?retention`,
    });
    await resp.arrayBuffer(); // consume body without use
    return {
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
    };
  }

  async putObjectTagging(
    params: s.PutObjectTaggingRequest,
  ): Promise<s.PutObjectTaggingOutput> {
    const inner = params["Tagging"];
    const body = inner ? xmlP.stringify({
      name: "Tagging",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "TagSet", children: inner["TagSet"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)}))},
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    const resp = await this.#client.performRequest({
      headers, query, body,
      action: "PutObjectTagging",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?tagging`,
    });
    await resp.arrayBuffer(); // consume body without use
    return {
      VersionId: resp.headers.get("x-amz-version-id"),
    };
  }

  async putPublicAccessBlock(
    params: s.PutPublicAccessBlockRequest,
  ): Promise<void> {
    const inner = params["PublicAccessBlockConfiguration"];
    const body = inner ? xmlP.stringify({
      name: "PublicAccessBlockConfiguration",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "BlockPublicAcls", content: inner["BlockPublicAcls"]?.toString()},
        {name: "IgnorePublicAcls", content: inner["IgnorePublicAcls"]?.toString()},
        {name: "BlockPublicPolicy", content: inner["BlockPublicPolicy"]?.toString()},
        {name: "RestrictPublicBuckets", content: inner["RestrictPublicBuckets"]?.toString()},
      ]}) : "";
    const headers = new Headers;
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "PutPublicAccessBlock",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}?publicAccessBlock`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async restoreObject(
    params: s.RestoreObjectRequest,
  ): Promise<s.RestoreObjectOutput> {
    const inner = params["RestoreRequest"];
    const body = inner ? xmlP.stringify({
      name: "RestoreRequest",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Days", content: inner["Days"]?.toString()},
        {name: "GlacierJobParameters", ...GlacierJobParameters_Serialize(inner["GlacierJobParameters"])},
        {name: "Type", content: inner["Type"]?.toString()},
        {name: "Tier", content: inner["Tier"]?.toString()},
        {name: "Description", content: inner["Description"]?.toString()},
        {name: "SelectParameters", ...SelectParameters_Serialize(inner["SelectParameters"])},
        {name: "OutputLocation", ...OutputLocation_Serialize(inner["OutputLocation"])},
      ]}) : "";
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["VersionId"] != null) query.set("versionId", params["VersionId"]?.toString() ?? "");
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query, body,
      action: "RestoreObject",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?restore`,
    });
    await resp.arrayBuffer(); // consume body without use
    return {
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
      RestoreOutputPath: resp.headers.get("x-amz-restore-output-path"),
    };
  }

  async selectObjectContent(
    params: s.SelectObjectContentRequest,
  ): Promise<s.SelectObjectContentOutput> {
    const headers = new Headers;
    const body = xmlP.stringify({
      name: "SelectObjectContentRequest",
      attributes: {"xmlns":"http://s3.amazonaws.com/doc/2006-03-01/"},
      children: [
        {name: "Expression", content: params["Expression"]?.toString()},
        {name: "ExpressionType", content: params["ExpressionType"]?.toString()},
        {name: "RequestProgress", ...RequestProgress_Serialize(params["RequestProgress"])},
        {name: "InputSerialization", ...InputSerialization_Serialize(params["InputSerialization"])},
        {name: "OutputSerialization", ...OutputSerialization_Serialize(params["OutputSerialization"])},
        {name: "ScanRange", ...ScanRange_Serialize(params["ScanRange"])},
      ]});
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSECustomerKey"] != null) headers.append("x-amz-server-side-encryption-customer-key", serializeBlob(params["SSECustomerKey"]) ?? '');
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, body,
      action: "SelectObjectContent",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}?select&select-type=2`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Payload: {
        Records: xml.first("Records", false, RecordsEvent_Parse),
        Stats: xml.first("Stats", false, StatsEvent_Parse),
        Progress: xml.first("Progress", false, ProgressEvent_Parse),
        Cont: xml.first("Cont", false, ContinuationEvent_Parse),
        End: xml.first("End", false, EndEvent_Parse),
      },
    };
  }

  async uploadPart(
    params: s.UploadPartRequest,
  ): Promise<s.UploadPartOutput> {
    const body = typeof params["Body"] === 'string' ? new TextEncoder().encode(params["Body"]) : params["Body"];
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["ContentLength"] != null) headers.append("Content-Length", params["ContentLength"]?.toString() ?? '');
    headers.append("Content-MD5", params["ContentMD5"] ?? hashMD5(body ?? ''));
    query.set("partNumber", params["PartNumber"]?.toString() ?? "");
    query.set("uploadId", params["UploadId"]?.toString() ?? "");
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSECustomerKey"] != null) headers.append("x-amz-server-side-encryption-customer-key", serializeBlob(params["SSECustomerKey"]) ?? '');
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query, body,
      action: "UploadPart",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
    });
    await resp.arrayBuffer(); // consume body without use
    return {
      ServerSideEncryption: cmnP.readEnum<s.ServerSideEncryption>(resp.headers.get("x-amz-server-side-encryption")),
      ETag: resp.headers.get("ETag"),
      SSECustomerAlgorithm: resp.headers.get("x-amz-server-side-encryption-customer-algorithm"),
      SSECustomerKeyMD5: resp.headers.get("x-amz-server-side-encryption-customer-key-MD5"),
      SSEKMSKeyId: resp.headers.get("x-amz-server-side-encryption-aws-kms-key-id"),
      BucketKeyEnabled: cmnP.readBool(resp.headers.get("x-amz-server-side-encryption-bucket-key-enabled")),
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
    };
  }

  async uploadPartCopy(
    params: s.UploadPartCopyRequest,
  ): Promise<s.UploadPartCopyOutput> {
    const headers = new Headers;
    const query = new URLSearchParams;
    headers.append("x-amz-copy-source", params["CopySource"]);
    if (params["CopySourceIfMatch"] != null) headers.append("x-amz-copy-source-if-match", params["CopySourceIfMatch"]);
    if (params["CopySourceIfModifiedSince"] != null) headers.append("x-amz-copy-source-if-modified-since", cmnP.serializeDate_rfc822(params["CopySourceIfModifiedSince"]) ?? "");
    if (params["CopySourceIfNoneMatch"] != null) headers.append("x-amz-copy-source-if-none-match", params["CopySourceIfNoneMatch"]);
    if (params["CopySourceIfUnmodifiedSince"] != null) headers.append("x-amz-copy-source-if-unmodified-since", cmnP.serializeDate_rfc822(params["CopySourceIfUnmodifiedSince"]) ?? "");
    if (params["CopySourceRange"] != null) headers.append("x-amz-copy-source-range", params["CopySourceRange"]);
    query.set("partNumber", params["PartNumber"]?.toString() ?? "");
    query.set("uploadId", params["UploadId"]?.toString() ?? "");
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSECustomerKey"] != null) headers.append("x-amz-server-side-encryption-customer-key", serializeBlob(params["SSECustomerKey"]) ?? '');
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["CopySourceSSECustomerAlgorithm"] != null) headers.append("x-amz-copy-source-server-side-encryption-customer-algorithm", params["CopySourceSSECustomerAlgorithm"]);
    if (params["CopySourceSSECustomerKey"] != null) headers.append("x-amz-copy-source-server-side-encryption-customer-key", serializeBlob(params["CopySourceSSECustomerKey"]) ?? '');
    if (params["CopySourceSSECustomerKeyMD5"] != null) headers.append("x-amz-copy-source-server-side-encryption-customer-key-MD5", params["CopySourceSSECustomerKeyMD5"]);
    if (params["RequestPayer"] != null) headers.append("x-amz-request-payer", params["RequestPayer"]);
    if (params["ExpectedBucketOwner"] != null) headers.append("x-amz-expected-bucket-owner", params["ExpectedBucketOwner"]);
    if (params["ExpectedSourceBucketOwner"] != null) headers.append("x-amz-source-expected-bucket-owner", params["ExpectedSourceBucketOwner"]);
    const resp = await this.#client.performRequest({
      headers, query,
      action: "UploadPartCopy",
      method: "PUT",
      requestUri: cmnP.encodePath`/${params["Bucket"]}/${params["Key"].split("/")}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CopySourceVersionId: resp.headers.get("x-amz-copy-source-version-id"),
      ServerSideEncryption: cmnP.readEnum<s.ServerSideEncryption>(resp.headers.get("x-amz-server-side-encryption")),
      SSECustomerAlgorithm: resp.headers.get("x-amz-server-side-encryption-customer-algorithm"),
      SSECustomerKeyMD5: resp.headers.get("x-amz-server-side-encryption-customer-key-MD5"),
      SSEKMSKeyId: resp.headers.get("x-amz-server-side-encryption-aws-kms-key-id"),
      BucketKeyEnabled: cmnP.readBool(resp.headers.get("x-amz-server-side-encryption-bucket-key-enabled")),
      RequestCharged: cmnP.readEnum<s.RequestCharged>(resp.headers.get("x-amz-request-charged")),
      CopyPartResult: {
        ...xml.strings({
          optional: {"ETag":true},
        }),
        LastModified: xml.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
      },
    };
  }

  async writeGetObjectResponse(
    params: s.WriteGetObjectResponseRequest,
  ): Promise<void> {
    const body = typeof params["Body"] === 'string' ? new TextEncoder().encode(params["Body"]) : params["Body"];
    const headers = new Headers;
    headers.append("x-amz-request-route", params["RequestRoute"]);
    headers.append("x-amz-request-token", params["RequestToken"]);
    if (params["StatusCode"] != null) headers.append("x-amz-fwd-status", params["StatusCode"]?.toString() ?? '');
    if (params["ErrorCode"] != null) headers.append("x-amz-fwd-error-code", params["ErrorCode"]);
    if (params["ErrorMessage"] != null) headers.append("x-amz-fwd-error-message", params["ErrorMessage"]);
    if (params["AcceptRanges"] != null) headers.append("x-amz-fwd-header-accept-ranges", params["AcceptRanges"]);
    if (params["CacheControl"] != null) headers.append("x-amz-fwd-header-Cache-Control", params["CacheControl"]);
    if (params["ContentDisposition"] != null) headers.append("x-amz-fwd-header-Content-Disposition", params["ContentDisposition"]);
    if (params["ContentEncoding"] != null) headers.append("x-amz-fwd-header-Content-Encoding", params["ContentEncoding"]);
    if (params["ContentLanguage"] != null) headers.append("x-amz-fwd-header-Content-Language", params["ContentLanguage"]);
    if (params["ContentLength"] != null) headers.append("Content-Length", params["ContentLength"]?.toString() ?? '');
    if (params["ContentRange"] != null) headers.append("x-amz-fwd-header-Content-Range", params["ContentRange"]);
    if (params["ContentType"] != null) headers.append("x-amz-fwd-header-Content-Type", params["ContentType"]);
    if (params["DeleteMarker"] != null) headers.append("x-amz-fwd-header-x-amz-delete-marker", params["DeleteMarker"]?.toString() ?? '');
    if (params["ETag"] != null) headers.append("x-amz-fwd-header-ETag", params["ETag"]);
    if (params["Expires"] != null) headers.append("x-amz-fwd-header-Expires", cmnP.serializeDate_rfc822(params["Expires"]) ?? "");
    if (params["Expiration"] != null) headers.append("x-amz-fwd-header-x-amz-expiration", params["Expiration"]);
    if (params["LastModified"] != null) headers.append("x-amz-fwd-header-Last-Modified", cmnP.serializeDate_rfc822(params["LastModified"]) ?? "");
    if (params["MissingMeta"] != null) headers.append("x-amz-fwd-header-x-amz-missing-meta", params["MissingMeta"]?.toString() ?? '');
    for (const [key, val] of Object.entries(params["Metadata"] ?? {})) {
      headers.append("x-amz-meta-"+key, val ?? "");
    }
    if (params["ObjectLockMode"] != null) headers.append("x-amz-fwd-header-x-amz-object-lock-mode", params["ObjectLockMode"]);
    if (params["ObjectLockLegalHoldStatus"] != null) headers.append("x-amz-fwd-header-x-amz-object-lock-legal-hold", params["ObjectLockLegalHoldStatus"]);
    if (params["ObjectLockRetainUntilDate"] != null) headers.append("x-amz-fwd-header-x-amz-object-lock-retain-until-date", cmnP.serializeDate_iso8601(params["ObjectLockRetainUntilDate"]) ?? "");
    if (params["PartsCount"] != null) headers.append("x-amz-fwd-header-x-amz-mp-parts-count", params["PartsCount"]?.toString() ?? '');
    if (params["ReplicationStatus"] != null) headers.append("x-amz-fwd-header-x-amz-replication-status", params["ReplicationStatus"]);
    if (params["RequestCharged"] != null) headers.append("x-amz-fwd-header-x-amz-request-charged", params["RequestCharged"]);
    if (params["Restore"] != null) headers.append("x-amz-fwd-header-x-amz-restore", params["Restore"]);
    if (params["ServerSideEncryption"] != null) headers.append("x-amz-fwd-header-x-amz-server-side-encryption", params["ServerSideEncryption"]);
    if (params["SSECustomerAlgorithm"] != null) headers.append("x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm", params["SSECustomerAlgorithm"]);
    if (params["SSEKMSKeyId"] != null) headers.append("x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id", params["SSEKMSKeyId"]);
    if (params["SSECustomerKeyMD5"] != null) headers.append("x-amz-fwd-header-x-amz-server-side-encryption-customer-key-MD5", params["SSECustomerKeyMD5"]);
    if (params["StorageClass"] != null) headers.append("x-amz-fwd-header-x-amz-storage-class", params["StorageClass"]);
    if (params["TagCount"] != null) headers.append("x-amz-fwd-header-x-amz-tagging-count", params["TagCount"]?.toString() ?? '');
    if (params["VersionId"] != null) headers.append("x-amz-fwd-header-x-amz-version-id", params["VersionId"]);
    if (params["BucketKeyEnabled"] != null) headers.append("x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled", params["BucketKeyEnabled"]?.toString() ?? '');
    const resp = await this.#client.performRequest({
      headers, body,
      action: "WriteGetObjectResponse",
      requestUri: "/WriteGetObjectResponse",
      hostPrefix: `${params.RequestRoute}.`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  // Resource State Waiters

  /** Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time). */
  async waitForBucketExists(
    params: s.HeadBucketRequest,
  ): Promise<Error | void> {
    const errMessage = 'ResourceNotReady: Resource is not in the state BucketExists';
    for (let i = 0; i < 20; i++) {
      try {
        await this.headBucket(params);
        return; // for status 200
        return; // for status 301
      } catch (err) {
        if (["Http403"].includes(err.shortCode)) return err;
        if (!["Http404"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time). */
  async waitForBucketNotExists(
    params: s.HeadBucketRequest,
  ): Promise<Error | void> {
    const errMessage = 'ResourceNotReady: Resource is not in the state BucketNotExists';
    for (let i = 0; i < 20; i++) {
      try {
        await this.headBucket(params);
      } catch (err) {
        if (["Http404"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time). */
  async waitForObjectExists(
    params: s.HeadObjectRequest,
  ): Promise<s.HeadObjectOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ObjectExists';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.headObject(params);
        return resp; // for status 200
      } catch (err) {
        if (!["Http404"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /** Checks state up to 20 times, 5 seconds apart (about 2 minutes max wait time). */
  async waitForObjectNotExists(
    params: s.HeadObjectRequest,
  ): Promise<Error | s.HeadObjectOutput> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ObjectNotExists';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.headObject(params);
      } catch (err) {
        if (["Http404"].includes(err.shortCode)) return err;
        throw err;
      }
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

}

function NotificationConfigurationDeprecated_Serialize(data: s.NotificationConfigurationDeprecated | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TopicConfiguration", ...TopicConfigurationDeprecated_Serialize(data["TopicConfiguration"])},
    {name: "QueueConfiguration", ...QueueConfigurationDeprecated_Serialize(data["QueueConfiguration"])},
    {name: "CloudFunctionConfiguration", ...CloudFunctionConfiguration_Serialize(data["CloudFunctionConfiguration"])},
  ]};
}
function NotificationConfigurationDeprecated_Parse(node: xmlP.XmlNode): s.NotificationConfigurationDeprecated {
  return {
    TopicConfiguration: node.first("TopicConfiguration", false, TopicConfigurationDeprecated_Parse),
    QueueConfiguration: node.first("QueueConfiguration", false, QueueConfigurationDeprecated_Parse),
    CloudFunctionConfiguration: node.first("CloudFunctionConfiguration", false, CloudFunctionConfiguration_Parse),
  };
}

function NotificationConfiguration_Serialize(data: s.NotificationConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["TopicConfigurations"]?.map(x => ({name: "TopicConfiguration", ...TopicConfiguration_Serialize(x)})) ?? []),
    ...(data["QueueConfigurations"]?.map(x => ({name: "QueueConfiguration", ...QueueConfiguration_Serialize(x)})) ?? []),
    ...(data["LambdaFunctionConfigurations"]?.map(x => ({name: "CloudFunctionConfiguration", ...LambdaFunctionConfiguration_Serialize(x)})) ?? []),
  ]};
}
function NotificationConfiguration_Parse(node: xmlP.XmlNode): s.NotificationConfiguration {
  return {
    TopicConfigurations: node.getList("TopicConfiguration").map(TopicConfiguration_Parse),
    QueueConfigurations: node.getList("QueueConfiguration").map(QueueConfiguration_Parse),
    LambdaFunctionConfigurations: node.getList("CloudFunctionConfiguration").map(LambdaFunctionConfiguration_Parse),
  };
}

function CompletedMultipartUpload_Serialize(data: s.CompletedMultipartUpload | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["Parts"]?.map(x => ({name: "Part", ...CompletedPart_Serialize(x)})) ?? []),
  ]};
}

function CompletedPart_Serialize(data: s.CompletedPart | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ETag", content: data["ETag"]?.toString()},
    {name: "PartNumber", content: data["PartNumber"]?.toString()},
  ]};
}

function CreateBucketConfiguration_Serialize(data: s.CreateBucketConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "LocationConstraint", content: data["LocationConstraint"]?.toString()},
  ]};
}

function Delete_Serialize(data: s.Delete | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["Objects"]?.map(x => ({name: "Object", ...ObjectIdentifier_Serialize(x)})) ?? []),
    {name: "Quiet", content: data["Quiet"]?.toString()},
  ]};
}

function ObjectIdentifier_Serialize(data: s.ObjectIdentifier | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Key", content: data["Key"]?.toString()},
    {name: "VersionId", content: data["VersionId"]?.toString()},
  ]};
}

function AccelerateConfiguration_Serialize(data: s.AccelerateConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
  ]};
}

function AccessControlPolicy_Serialize(data: s.AccessControlPolicy | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "AccessControlList", children: data["Grants"]?.map(x => ({name: "Grant", ...Grant_Serialize(x)}))},
    {name: "Owner", ...Owner_Serialize(data["Owner"])},
  ]};
}

function Grant_Serialize(data: s.Grant | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Grantee", ...Grantee_Serialize(data["Grantee"])},
    {name: "Permission", content: data["Permission"]?.toString()},
  ]};
}
function Grant_Parse(node: xmlP.XmlNode): s.Grant {
  return {
    Grantee: node.first("Grantee", false, Grantee_Parse),
    Permission: node.first("Permission", false, x => (x.content ?? '') as s.Permission),
  };
}

function Grantee_Serialize(data: s.Grantee | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {attributes: {
    "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
    "xsi:type": data["Type"] ?? undefined,
  }, children: [
    {name: "DisplayName", content: data["DisplayName"]?.toString()},
    {name: "EmailAddress", content: data["EmailAddress"]?.toString()},
    {name: "ID", content: data["ID"]?.toString()},
    {name: "URI", content: data["URI"]?.toString()},
  ]};
}
function Grantee_Parse(node: xmlP.XmlNode): s.Grantee {
  return {
    ...node.strings({
      optional: {"DisplayName":true,"EmailAddress":true,"ID":true,"URI":true},
    }),
    Type: cmnP.readEnumReq<s.Type>(node.attributes["xsi:type"]),
  };
}

function Owner_Serialize(data: s.Owner | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DisplayName", content: data["DisplayName"]?.toString()},
    {name: "ID", content: data["ID"]?.toString()},
  ]};
}
function Owner_Parse(node: xmlP.XmlNode): s.Owner {
  return node.strings({
    optional: {"DisplayName":true,"ID":true},
  });
}

function AnalyticsConfiguration_Serialize(data: s.AnalyticsConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "Filter", ...AnalyticsFilter_Serialize(data["Filter"])},
    {name: "StorageClassAnalysis", ...StorageClassAnalysis_Serialize(data["StorageClassAnalysis"])},
  ]};
}
function AnalyticsConfiguration_Parse(node: xmlP.XmlNode): s.AnalyticsConfiguration {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    Filter: node.first("Filter", false, AnalyticsFilter_Parse),
    StorageClassAnalysis: node.first("StorageClassAnalysis", true, StorageClassAnalysis_Parse),
  };
}

function AnalyticsFilter_Serialize(data: s.AnalyticsFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Tag", ...Tag_Serialize(data["Tag"])},
    {name: "And", ...AnalyticsAndOperator_Serialize(data["And"])},
  ]};
}
function AnalyticsFilter_Parse(node: xmlP.XmlNode): s.AnalyticsFilter {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tag: node.first("Tag", false, Tag_Parse),
    And: node.first("And", false, AnalyticsAndOperator_Parse),
  };
}

function Tag_Serialize(data: s.Tag | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Key", content: data["Key"]?.toString()},
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function Tag_Parse(node: xmlP.XmlNode): s.Tag {
  return node.strings({
    required: {"Key":true,"Value":true},
  });
}

function AnalyticsAndOperator_Serialize(data: s.AnalyticsAndOperator | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    ...(data["Tags"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)})) ?? []),
  ]};
}
function AnalyticsAndOperator_Parse(node: xmlP.XmlNode): s.AnalyticsAndOperator {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tags: node.getList("Tag").map(Tag_Parse),
  };
}

function StorageClassAnalysis_Serialize(data: s.StorageClassAnalysis | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DataExport", ...StorageClassAnalysisDataExport_Serialize(data["DataExport"])},
  ]};
}
function StorageClassAnalysis_Parse(node: xmlP.XmlNode): s.StorageClassAnalysis {
  return {
    DataExport: node.first("DataExport", false, StorageClassAnalysisDataExport_Parse),
  };
}

function StorageClassAnalysisDataExport_Serialize(data: s.StorageClassAnalysisDataExport | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "OutputSchemaVersion", content: data["OutputSchemaVersion"]?.toString()},
    {name: "Destination", ...AnalyticsExportDestination_Serialize(data["Destination"])},
  ]};
}
function StorageClassAnalysisDataExport_Parse(node: xmlP.XmlNode): s.StorageClassAnalysisDataExport {
  return {
    OutputSchemaVersion: node.first("OutputSchemaVersion", true, x => (x.content ?? '') as s.StorageClassAnalysisSchemaVersion),
    Destination: node.first("Destination", true, AnalyticsExportDestination_Parse),
  };
}

function AnalyticsExportDestination_Serialize(data: s.AnalyticsExportDestination | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "S3BucketDestination", ...AnalyticsS3BucketDestination_Serialize(data["S3BucketDestination"])},
  ]};
}
function AnalyticsExportDestination_Parse(node: xmlP.XmlNode): s.AnalyticsExportDestination {
  return {
    S3BucketDestination: node.first("S3BucketDestination", true, AnalyticsS3BucketDestination_Parse),
  };
}

function AnalyticsS3BucketDestination_Serialize(data: s.AnalyticsS3BucketDestination | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Format", content: data["Format"]?.toString()},
    {name: "BucketAccountId", content: data["BucketAccountId"]?.toString()},
    {name: "Bucket", content: data["Bucket"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
  ]};
}
function AnalyticsS3BucketDestination_Parse(node: xmlP.XmlNode): s.AnalyticsS3BucketDestination {
  return {
    ...node.strings({
      required: {"Bucket":true},
      optional: {"BucketAccountId":true,"Prefix":true},
    }),
    Format: node.first("Format", true, x => (x.content ?? '') as s.AnalyticsS3ExportFileFormat),
  };
}

function CORSConfiguration_Serialize(data: s.CORSConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["CORSRules"]?.map(x => ({name: "CORSRule", ...CORSRule_Serialize(x)})) ?? []),
  ]};
}

function CORSRule_Serialize(data: s.CORSRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ID", content: data["ID"]?.toString()},
    ...(data["AllowedHeaders"]?.map(x => ({name: "AllowedHeader", content: x})) ?? []),
    ...(data["AllowedMethods"]?.map(x => ({name: "AllowedMethod", content: x})) ?? []),
    ...(data["AllowedOrigins"]?.map(x => ({name: "AllowedOrigin", content: x})) ?? []),
    ...(data["ExposeHeaders"]?.map(x => ({name: "ExposeHeader", content: x})) ?? []),
    {name: "MaxAgeSeconds", content: data["MaxAgeSeconds"]?.toString()},
  ]};
}
function CORSRule_Parse(node: xmlP.XmlNode): s.CORSRule {
  return {
    ...node.strings({
      optional: {"ID":true},
    }),
    AllowedHeaders: node.getList("AllowedHeader").map(x => x.content ?? ''),
    AllowedMethods: node.getList("AllowedMethod").map(x => x.content ?? ''),
    AllowedOrigins: node.getList("AllowedOrigin").map(x => x.content ?? ''),
    ExposeHeaders: node.getList("ExposeHeader").map(x => x.content ?? ''),
    MaxAgeSeconds: node.first("MaxAgeSeconds", false, x => parseInt(x.content ?? '0')),
  };
}

function ServerSideEncryptionConfiguration_Serialize(data: s.ServerSideEncryptionConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["Rules"]?.map(x => ({name: "Rule", ...ServerSideEncryptionRule_Serialize(x)})) ?? []),
  ]};
}
function ServerSideEncryptionConfiguration_Parse(node: xmlP.XmlNode): s.ServerSideEncryptionConfiguration {
  return {
    Rules: node.getList("Rule").map(ServerSideEncryptionRule_Parse),
  };
}

function ServerSideEncryptionRule_Serialize(data: s.ServerSideEncryptionRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ApplyServerSideEncryptionByDefault", ...ServerSideEncryptionByDefault_Serialize(data["ApplyServerSideEncryptionByDefault"])},
    {name: "BucketKeyEnabled", content: data["BucketKeyEnabled"]?.toString()},
  ]};
}
function ServerSideEncryptionRule_Parse(node: xmlP.XmlNode): s.ServerSideEncryptionRule {
  return {
    ApplyServerSideEncryptionByDefault: node.first("ApplyServerSideEncryptionByDefault", false, ServerSideEncryptionByDefault_Parse),
    BucketKeyEnabled: node.first("BucketKeyEnabled", false, x => x.content === 'true'),
  };
}

function ServerSideEncryptionByDefault_Serialize(data: s.ServerSideEncryptionByDefault | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "SSEAlgorithm", content: data["SSEAlgorithm"]?.toString()},
    {name: "KMSMasterKeyID", content: data["KMSMasterKeyID"]?.toString()},
  ]};
}
function ServerSideEncryptionByDefault_Parse(node: xmlP.XmlNode): s.ServerSideEncryptionByDefault {
  return {
    ...node.strings({
      optional: {"KMSMasterKeyID":true},
    }),
    SSEAlgorithm: node.first("SSEAlgorithm", true, x => (x.content ?? '') as s.ServerSideEncryption),
  };
}

function IntelligentTieringConfiguration_Serialize(data: s.IntelligentTieringConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "Filter", ...IntelligentTieringFilter_Serialize(data["Filter"])},
    {name: "Status", content: data["Status"]?.toString()},
    ...(data["Tierings"]?.map(x => ({name: "Tiering", ...Tiering_Serialize(x)})) ?? []),
  ]};
}
function IntelligentTieringConfiguration_Parse(node: xmlP.XmlNode): s.IntelligentTieringConfiguration {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    Filter: node.first("Filter", false, IntelligentTieringFilter_Parse),
    Status: node.first("Status", true, x => (x.content ?? '') as s.IntelligentTieringStatus),
    Tierings: node.getList("Tiering").map(Tiering_Parse),
  };
}

function IntelligentTieringFilter_Serialize(data: s.IntelligentTieringFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Tag", ...Tag_Serialize(data["Tag"])},
    {name: "And", ...IntelligentTieringAndOperator_Serialize(data["And"])},
  ]};
}
function IntelligentTieringFilter_Parse(node: xmlP.XmlNode): s.IntelligentTieringFilter {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tag: node.first("Tag", false, Tag_Parse),
    And: node.first("And", false, IntelligentTieringAndOperator_Parse),
  };
}

function IntelligentTieringAndOperator_Serialize(data: s.IntelligentTieringAndOperator | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    ...(data["Tags"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)})) ?? []),
  ]};
}
function IntelligentTieringAndOperator_Parse(node: xmlP.XmlNode): s.IntelligentTieringAndOperator {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tags: node.getList("Tag").map(Tag_Parse),
  };
}

function Tiering_Serialize(data: s.Tiering | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Days", content: data["Days"]?.toString()},
    {name: "AccessTier", content: data["AccessTier"]?.toString()},
  ]};
}
function Tiering_Parse(node: xmlP.XmlNode): s.Tiering {
  return {
    Days: node.first("Days", true, x => parseInt(x.content ?? '0')),
    AccessTier: node.first("AccessTier", true, x => (x.content ?? '') as s.IntelligentTieringAccessTier),
  };
}

function InventoryConfiguration_Serialize(data: s.InventoryConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Destination", ...InventoryDestination_Serialize(data["Destination"])},
    {name: "IsEnabled", content: data["IsEnabled"]?.toString()},
    {name: "Filter", ...InventoryFilter_Serialize(data["Filter"])},
    {name: "Id", content: data["Id"]?.toString()},
    {name: "IncludedObjectVersions", content: data["IncludedObjectVersions"]?.toString()},
    {name: "OptionalFields", children: data["OptionalFields"]?.map(x => ({name: "Field", content: x}))},
    {name: "Schedule", ...InventorySchedule_Serialize(data["Schedule"])},
  ]};
}
function InventoryConfiguration_Parse(node: xmlP.XmlNode): s.InventoryConfiguration {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    Destination: node.first("Destination", true, InventoryDestination_Parse),
    IsEnabled: node.first("IsEnabled", true, x => x.content === 'true'),
    Filter: node.first("Filter", false, InventoryFilter_Parse),
    IncludedObjectVersions: node.first("IncludedObjectVersions", true, x => (x.content ?? '') as s.InventoryIncludedObjectVersions),
    OptionalFields: node.getList("OptionalFields", "Field").map(x => (x.content ?? '') as s.InventoryOptionalField),
    Schedule: node.first("Schedule", true, InventorySchedule_Parse),
  };
}

function InventoryDestination_Serialize(data: s.InventoryDestination | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "S3BucketDestination", ...InventoryS3BucketDestination_Serialize(data["S3BucketDestination"])},
  ]};
}
function InventoryDestination_Parse(node: xmlP.XmlNode): s.InventoryDestination {
  return {
    S3BucketDestination: node.first("S3BucketDestination", true, InventoryS3BucketDestination_Parse),
  };
}

function InventoryS3BucketDestination_Serialize(data: s.InventoryS3BucketDestination | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "AccountId", content: data["AccountId"]?.toString()},
    {name: "Bucket", content: data["Bucket"]?.toString()},
    {name: "Format", content: data["Format"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Encryption", ...InventoryEncryption_Serialize(data["Encryption"])},
  ]};
}
function InventoryS3BucketDestination_Parse(node: xmlP.XmlNode): s.InventoryS3BucketDestination {
  return {
    ...node.strings({
      required: {"Bucket":true},
      optional: {"AccountId":true,"Prefix":true},
    }),
    Format: node.first("Format", true, x => (x.content ?? '') as s.InventoryFormat),
    Encryption: node.first("Encryption", false, InventoryEncryption_Parse),
  };
}

function InventoryEncryption_Serialize(data: s.InventoryEncryption | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "SSE-S3", ...SSES3_Serialize(data["SSES3"])},
    {name: "SSE-KMS", ...SSEKMS_Serialize(data["SSEKMS"])},
  ]};
}
function InventoryEncryption_Parse(node: xmlP.XmlNode): s.InventoryEncryption {
  return {
    SSES3: node.first("SSE-S3", false, SSES3_Parse),
    SSEKMS: node.first("SSE-KMS", false, SSEKMS_Parse),
  };
}

function SSES3_Serialize(data: s.SSES3 | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [

  ]};
}
function SSES3_Parse(node: xmlP.XmlNode): s.SSES3 {
  return {};
}

function SSEKMS_Serialize(data: s.SSEKMS | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "KeyId", content: data["KeyId"]?.toString()},
  ]};
}
function SSEKMS_Parse(node: xmlP.XmlNode): s.SSEKMS {
  return node.strings({
    required: {"KeyId":true},
  });
}

function InventoryFilter_Serialize(data: s.InventoryFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
  ]};
}
function InventoryFilter_Parse(node: xmlP.XmlNode): s.InventoryFilter {
  return node.strings({
    required: {"Prefix":true},
  });
}

function InventorySchedule_Serialize(data: s.InventorySchedule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Frequency", content: data["Frequency"]?.toString()},
  ]};
}
function InventorySchedule_Parse(node: xmlP.XmlNode): s.InventorySchedule {
  return {
    Frequency: node.first("Frequency", true, x => (x.content ?? '') as s.InventoryFrequency),
  };
}

function LifecycleConfiguration_Serialize(data: s.LifecycleConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["Rules"]?.map(x => ({name: "Rule", ...Rule_Serialize(x)})) ?? []),
  ]};
}

function Rule_Serialize(data: s.Rule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Expiration", ...LifecycleExpiration_Serialize(data["Expiration"])},
    {name: "ID", content: data["ID"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Status", content: data["Status"]?.toString()},
    {name: "Transition", ...Transition_Serialize(data["Transition"])},
    {name: "NoncurrentVersionTransition", ...NoncurrentVersionTransition_Serialize(data["NoncurrentVersionTransition"])},
    {name: "NoncurrentVersionExpiration", ...NoncurrentVersionExpiration_Serialize(data["NoncurrentVersionExpiration"])},
    {name: "AbortIncompleteMultipartUpload", ...AbortIncompleteMultipartUpload_Serialize(data["AbortIncompleteMultipartUpload"])},
  ]};
}
function Rule_Parse(node: xmlP.XmlNode): s.Rule {
  return {
    ...node.strings({
      required: {"Prefix":true},
      optional: {"ID":true},
    }),
    Expiration: node.first("Expiration", false, LifecycleExpiration_Parse),
    Status: node.first("Status", true, x => (x.content ?? '') as s.ExpirationStatus),
    Transition: node.first("Transition", false, Transition_Parse),
    NoncurrentVersionTransition: node.first("NoncurrentVersionTransition", false, NoncurrentVersionTransition_Parse),
    NoncurrentVersionExpiration: node.first("NoncurrentVersionExpiration", false, NoncurrentVersionExpiration_Parse),
    AbortIncompleteMultipartUpload: node.first("AbortIncompleteMultipartUpload", false, AbortIncompleteMultipartUpload_Parse),
  };
}

function LifecycleExpiration_Serialize(data: s.LifecycleExpiration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Date", content: cmnP.serializeDate_iso8601(data["Date"])},
    {name: "Days", content: data["Days"]?.toString()},
    {name: "ExpiredObjectDeleteMarker", content: data["ExpiredObjectDeleteMarker"]?.toString()},
  ]};
}
function LifecycleExpiration_Parse(node: xmlP.XmlNode): s.LifecycleExpiration {
  return {
    Date: node.first("Date", false, x => xmlP.parseTimestamp(x.content)),
    Days: node.first("Days", false, x => parseInt(x.content ?? '0')),
    ExpiredObjectDeleteMarker: node.first("ExpiredObjectDeleteMarker", false, x => x.content === 'true'),
  };
}

function Transition_Serialize(data: s.Transition | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Date", content: cmnP.serializeDate_iso8601(data["Date"])},
    {name: "Days", content: data["Days"]?.toString()},
    {name: "StorageClass", content: data["StorageClass"]?.toString()},
  ]};
}
function Transition_Parse(node: xmlP.XmlNode): s.Transition {
  return {
    Date: node.first("Date", false, x => xmlP.parseTimestamp(x.content)),
    Days: node.first("Days", false, x => parseInt(x.content ?? '0')),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as s.TransitionStorageClass),
  };
}

function NoncurrentVersionTransition_Serialize(data: s.NoncurrentVersionTransition | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "NoncurrentDays", content: data["NoncurrentDays"]?.toString()},
    {name: "StorageClass", content: data["StorageClass"]?.toString()},
  ]};
}
function NoncurrentVersionTransition_Parse(node: xmlP.XmlNode): s.NoncurrentVersionTransition {
  return {
    NoncurrentDays: node.first("NoncurrentDays", false, x => parseInt(x.content ?? '0')),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as s.TransitionStorageClass),
  };
}

function NoncurrentVersionExpiration_Serialize(data: s.NoncurrentVersionExpiration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "NoncurrentDays", content: data["NoncurrentDays"]?.toString()},
  ]};
}
function NoncurrentVersionExpiration_Parse(node: xmlP.XmlNode): s.NoncurrentVersionExpiration {
  return {
    NoncurrentDays: node.first("NoncurrentDays", false, x => parseInt(x.content ?? '0')),
  };
}

function AbortIncompleteMultipartUpload_Serialize(data: s.AbortIncompleteMultipartUpload | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DaysAfterInitiation", content: data["DaysAfterInitiation"]?.toString()},
  ]};
}
function AbortIncompleteMultipartUpload_Parse(node: xmlP.XmlNode): s.AbortIncompleteMultipartUpload {
  return {
    DaysAfterInitiation: node.first("DaysAfterInitiation", false, x => parseInt(x.content ?? '0')),
  };
}

function BucketLifecycleConfiguration_Serialize(data: s.BucketLifecycleConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["Rules"]?.map(x => ({name: "Rule", ...LifecycleRule_Serialize(x)})) ?? []),
  ]};
}

function LifecycleRule_Serialize(data: s.LifecycleRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Expiration", ...LifecycleExpiration_Serialize(data["Expiration"])},
    {name: "ID", content: data["ID"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Filter", ...LifecycleRuleFilter_Serialize(data["Filter"])},
    {name: "Status", content: data["Status"]?.toString()},
    ...(data["Transitions"]?.map(x => ({name: "Transition", ...Transition_Serialize(x)})) ?? []),
    ...(data["NoncurrentVersionTransitions"]?.map(x => ({name: "NoncurrentVersionTransition", ...NoncurrentVersionTransition_Serialize(x)})) ?? []),
    {name: "NoncurrentVersionExpiration", ...NoncurrentVersionExpiration_Serialize(data["NoncurrentVersionExpiration"])},
    {name: "AbortIncompleteMultipartUpload", ...AbortIncompleteMultipartUpload_Serialize(data["AbortIncompleteMultipartUpload"])},
  ]};
}
function LifecycleRule_Parse(node: xmlP.XmlNode): s.LifecycleRule {
  return {
    ...node.strings({
      optional: {"ID":true,"Prefix":true},
    }),
    Expiration: node.first("Expiration", false, LifecycleExpiration_Parse),
    Filter: node.first("Filter", false, LifecycleRuleFilter_Parse),
    Status: node.first("Status", true, x => (x.content ?? '') as s.ExpirationStatus),
    Transitions: node.getList("Transition").map(Transition_Parse),
    NoncurrentVersionTransitions: node.getList("NoncurrentVersionTransition").map(NoncurrentVersionTransition_Parse),
    NoncurrentVersionExpiration: node.first("NoncurrentVersionExpiration", false, NoncurrentVersionExpiration_Parse),
    AbortIncompleteMultipartUpload: node.first("AbortIncompleteMultipartUpload", false, AbortIncompleteMultipartUpload_Parse),
  };
}

function LifecycleRuleFilter_Serialize(data: s.LifecycleRuleFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Tag", ...Tag_Serialize(data["Tag"])},
    {name: "And", ...LifecycleRuleAndOperator_Serialize(data["And"])},
  ]};
}
function LifecycleRuleFilter_Parse(node: xmlP.XmlNode): s.LifecycleRuleFilter {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tag: node.first("Tag", false, Tag_Parse),
    And: node.first("And", false, LifecycleRuleAndOperator_Parse),
  };
}

function LifecycleRuleAndOperator_Serialize(data: s.LifecycleRuleAndOperator | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    ...(data["Tags"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)})) ?? []),
  ]};
}
function LifecycleRuleAndOperator_Parse(node: xmlP.XmlNode): s.LifecycleRuleAndOperator {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tags: node.getList("Tag").map(Tag_Parse),
  };
}

function BucketLoggingStatus_Serialize(data: s.BucketLoggingStatus | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "LoggingEnabled", ...LoggingEnabled_Serialize(data["LoggingEnabled"])},
  ]};
}

function LoggingEnabled_Serialize(data: s.LoggingEnabled | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TargetBucket", content: data["TargetBucket"]?.toString()},
    {name: "TargetGrants", children: data["TargetGrants"]?.map(x => ({name: "Grant", ...TargetGrant_Serialize(x)}))},
    {name: "TargetPrefix", content: data["TargetPrefix"]?.toString()},
  ]};
}
function LoggingEnabled_Parse(node: xmlP.XmlNode): s.LoggingEnabled {
  return {
    ...node.strings({
      required: {"TargetBucket":true,"TargetPrefix":true},
    }),
    TargetGrants: node.getList("TargetGrants", "Grant").map(TargetGrant_Parse),
  };
}

function TargetGrant_Serialize(data: s.TargetGrant | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Grantee", ...Grantee_Serialize(data["Grantee"])},
    {name: "Permission", content: data["Permission"]?.toString()},
  ]};
}
function TargetGrant_Parse(node: xmlP.XmlNode): s.TargetGrant {
  return {
    Grantee: node.first("Grantee", false, Grantee_Parse),
    Permission: node.first("Permission", false, x => (x.content ?? '') as s.BucketLogsPermission),
  };
}

function MetricsConfiguration_Serialize(data: s.MetricsConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "Filter", ...MetricsFilter_Serialize(data["Filter"])},
  ]};
}
function MetricsConfiguration_Parse(node: xmlP.XmlNode): s.MetricsConfiguration {
  return {
    ...node.strings({
      required: {"Id":true},
    }),
    Filter: node.first("Filter", false, MetricsFilter_Parse),
  };
}

function MetricsFilter_Serialize(data: s.MetricsFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Tag", ...Tag_Serialize(data["Tag"])},
    {name: "And", ...MetricsAndOperator_Serialize(data["And"])},
  ]};
}
function MetricsFilter_Parse(node: xmlP.XmlNode): s.MetricsFilter {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tag: node.first("Tag", false, Tag_Parse),
    And: node.first("And", false, MetricsAndOperator_Parse),
  };
}

function MetricsAndOperator_Serialize(data: s.MetricsAndOperator | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    ...(data["Tags"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)})) ?? []),
  ]};
}
function MetricsAndOperator_Parse(node: xmlP.XmlNode): s.MetricsAndOperator {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tags: node.getList("Tag").map(Tag_Parse),
  };
}

function TopicConfigurationDeprecated_Serialize(data: s.TopicConfigurationDeprecated | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    ...(data["Events"]?.map(x => ({name: "Event", content: x})) ?? []),
    {name: "Event", content: data["Event"]?.toString()},
    {name: "Topic", content: data["Topic"]?.toString()},
  ]};
}
function TopicConfigurationDeprecated_Parse(node: xmlP.XmlNode): s.TopicConfigurationDeprecated {
  return {
    ...node.strings({
      optional: {"Id":true,"Topic":true},
    }),
    Events: node.getList("Event").map(x => (x.content ?? '') as s.Event),
    Event: node.first("Event", false, x => (x.content ?? '') as s.Event),
  };
}

function QueueConfigurationDeprecated_Serialize(data: s.QueueConfigurationDeprecated | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "Event", content: data["Event"]?.toString()},
    ...(data["Events"]?.map(x => ({name: "Event", content: x})) ?? []),
    {name: "Queue", content: data["Queue"]?.toString()},
  ]};
}
function QueueConfigurationDeprecated_Parse(node: xmlP.XmlNode): s.QueueConfigurationDeprecated {
  return {
    ...node.strings({
      optional: {"Id":true,"Queue":true},
    }),
    Event: node.first("Event", false, x => (x.content ?? '') as s.Event),
    Events: node.getList("Event").map(x => (x.content ?? '') as s.Event),
  };
}

function CloudFunctionConfiguration_Serialize(data: s.CloudFunctionConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "Event", content: data["Event"]?.toString()},
    ...(data["Events"]?.map(x => ({name: "Event", content: x})) ?? []),
    {name: "CloudFunction", content: data["CloudFunction"]?.toString()},
    {name: "InvocationRole", content: data["InvocationRole"]?.toString()},
  ]};
}
function CloudFunctionConfiguration_Parse(node: xmlP.XmlNode): s.CloudFunctionConfiguration {
  return {
    ...node.strings({
      optional: {"Id":true,"CloudFunction":true,"InvocationRole":true},
    }),
    Event: node.first("Event", false, x => (x.content ?? '') as s.Event),
    Events: node.getList("Event").map(x => (x.content ?? '') as s.Event),
  };
}

function TopicConfiguration_Serialize(data: s.TopicConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "Topic", content: data["TopicArn"]?.toString()},
    ...(data["Events"]?.map(x => ({name: "Event", content: x})) ?? []),
    {name: "Filter", ...NotificationConfigurationFilter_Serialize(data["Filter"])},
  ]};
}
function TopicConfiguration_Parse(node: xmlP.XmlNode): s.TopicConfiguration {
  return {
    ...node.strings({
      optional: {"Id":true},
    }),
    TopicArn: node.first("Topic", true, x => x.content ?? ''),
    Events: node.getList("Event").map(x => (x.content ?? '') as s.Event),
    Filter: node.first("Filter", false, NotificationConfigurationFilter_Parse),
  };
}

function NotificationConfigurationFilter_Serialize(data: s.NotificationConfigurationFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "S3Key", ...S3KeyFilter_Serialize(data["Key"])},
  ]};
}
function NotificationConfigurationFilter_Parse(node: xmlP.XmlNode): s.NotificationConfigurationFilter {
  return {
    Key: node.first("S3Key", false, S3KeyFilter_Parse),
  };
}

function S3KeyFilter_Serialize(data: s.S3KeyFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["FilterRules"]?.map(x => ({name: "FilterRule", ...FilterRule_Serialize(x)})) ?? []),
  ]};
}
function S3KeyFilter_Parse(node: xmlP.XmlNode): s.S3KeyFilter {
  return {
    FilterRules: node.getList("FilterRule").map(FilterRule_Parse),
  };
}

function FilterRule_Serialize(data: s.FilterRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Name", content: data["Name"]?.toString()},
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function FilterRule_Parse(node: xmlP.XmlNode): s.FilterRule {
  return {
    ...node.strings({
      optional: {"Value":true},
    }),
    Name: node.first("Name", false, x => (x.content ?? '') as s.FilterRuleName),
  };
}

function QueueConfiguration_Serialize(data: s.QueueConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "Queue", content: data["QueueArn"]?.toString()},
    ...(data["Events"]?.map(x => ({name: "Event", content: x})) ?? []),
    {name: "Filter", ...NotificationConfigurationFilter_Serialize(data["Filter"])},
  ]};
}
function QueueConfiguration_Parse(node: xmlP.XmlNode): s.QueueConfiguration {
  return {
    ...node.strings({
      optional: {"Id":true},
    }),
    QueueArn: node.first("Queue", true, x => x.content ?? ''),
    Events: node.getList("Event").map(x => (x.content ?? '') as s.Event),
    Filter: node.first("Filter", false, NotificationConfigurationFilter_Parse),
  };
}

function LambdaFunctionConfiguration_Serialize(data: s.LambdaFunctionConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Id", content: data["Id"]?.toString()},
    {name: "CloudFunction", content: data["LambdaFunctionArn"]?.toString()},
    ...(data["Events"]?.map(x => ({name: "Event", content: x})) ?? []),
    {name: "Filter", ...NotificationConfigurationFilter_Serialize(data["Filter"])},
  ]};
}
function LambdaFunctionConfiguration_Parse(node: xmlP.XmlNode): s.LambdaFunctionConfiguration {
  return {
    ...node.strings({
      optional: {"Id":true},
    }),
    LambdaFunctionArn: node.first("CloudFunction", true, x => x.content ?? ''),
    Events: node.getList("Event").map(x => (x.content ?? '') as s.Event),
    Filter: node.first("Filter", false, NotificationConfigurationFilter_Parse),
  };
}

function OwnershipControls_Serialize(data: s.OwnershipControls | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    ...(data["Rules"]?.map(x => ({name: "Rule", ...OwnershipControlsRule_Serialize(x)})) ?? []),
  ]};
}
function OwnershipControls_Parse(node: xmlP.XmlNode): s.OwnershipControls {
  return {
    Rules: node.getList("Rule").map(OwnershipControlsRule_Parse),
  };
}

function OwnershipControlsRule_Serialize(data: s.OwnershipControlsRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ObjectOwnership", content: data["ObjectOwnership"]?.toString()},
  ]};
}
function OwnershipControlsRule_Parse(node: xmlP.XmlNode): s.OwnershipControlsRule {
  return {
    ObjectOwnership: node.first("ObjectOwnership", true, x => (x.content ?? '') as s.ObjectOwnership),
  };
}

function ReplicationConfiguration_Serialize(data: s.ReplicationConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Role", content: data["Role"]?.toString()},
    ...(data["Rules"]?.map(x => ({name: "Rule", ...ReplicationRule_Serialize(x)})) ?? []),
  ]};
}
function ReplicationConfiguration_Parse(node: xmlP.XmlNode): s.ReplicationConfiguration {
  return {
    ...node.strings({
      required: {"Role":true},
    }),
    Rules: node.getList("Rule").map(ReplicationRule_Parse),
  };
}

function ReplicationRule_Serialize(data: s.ReplicationRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ID", content: data["ID"]?.toString()},
    {name: "Priority", content: data["Priority"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Filter", ...ReplicationRuleFilter_Serialize(data["Filter"])},
    {name: "Status", content: data["Status"]?.toString()},
    {name: "SourceSelectionCriteria", ...SourceSelectionCriteria_Serialize(data["SourceSelectionCriteria"])},
    {name: "ExistingObjectReplication", ...ExistingObjectReplication_Serialize(data["ExistingObjectReplication"])},
    {name: "Destination", ...Destination_Serialize(data["Destination"])},
    {name: "DeleteMarkerReplication", ...DeleteMarkerReplication_Serialize(data["DeleteMarkerReplication"])},
  ]};
}
function ReplicationRule_Parse(node: xmlP.XmlNode): s.ReplicationRule {
  return {
    ...node.strings({
      optional: {"ID":true,"Prefix":true},
    }),
    Priority: node.first("Priority", false, x => parseInt(x.content ?? '0')),
    Filter: node.first("Filter", false, ReplicationRuleFilter_Parse),
    Status: node.first("Status", true, x => (x.content ?? '') as s.ReplicationRuleStatus),
    SourceSelectionCriteria: node.first("SourceSelectionCriteria", false, SourceSelectionCriteria_Parse),
    ExistingObjectReplication: node.first("ExistingObjectReplication", false, ExistingObjectReplication_Parse),
    Destination: node.first("Destination", true, Destination_Parse),
    DeleteMarkerReplication: node.first("DeleteMarkerReplication", false, DeleteMarkerReplication_Parse),
  };
}

function ReplicationRuleFilter_Serialize(data: s.ReplicationRuleFilter | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Tag", ...Tag_Serialize(data["Tag"])},
    {name: "And", ...ReplicationRuleAndOperator_Serialize(data["And"])},
  ]};
}
function ReplicationRuleFilter_Parse(node: xmlP.XmlNode): s.ReplicationRuleFilter {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tag: node.first("Tag", false, Tag_Parse),
    And: node.first("And", false, ReplicationRuleAndOperator_Parse),
  };
}

function ReplicationRuleAndOperator_Serialize(data: s.ReplicationRuleAndOperator | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Prefix", content: data["Prefix"]?.toString()},
    ...(data["Tags"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)})) ?? []),
  ]};
}
function ReplicationRuleAndOperator_Parse(node: xmlP.XmlNode): s.ReplicationRuleAndOperator {
  return {
    ...node.strings({
      optional: {"Prefix":true},
    }),
    Tags: node.getList("Tag").map(Tag_Parse),
  };
}

function SourceSelectionCriteria_Serialize(data: s.SourceSelectionCriteria | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "SseKmsEncryptedObjects", ...SseKmsEncryptedObjects_Serialize(data["SseKmsEncryptedObjects"])},
    {name: "ReplicaModifications", ...ReplicaModifications_Serialize(data["ReplicaModifications"])},
  ]};
}
function SourceSelectionCriteria_Parse(node: xmlP.XmlNode): s.SourceSelectionCriteria {
  return {
    SseKmsEncryptedObjects: node.first("SseKmsEncryptedObjects", false, SseKmsEncryptedObjects_Parse),
    ReplicaModifications: node.first("ReplicaModifications", false, ReplicaModifications_Parse),
  };
}

function SseKmsEncryptedObjects_Serialize(data: s.SseKmsEncryptedObjects | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
  ]};
}
function SseKmsEncryptedObjects_Parse(node: xmlP.XmlNode): s.SseKmsEncryptedObjects {
  return {
    Status: node.first("Status", true, x => (x.content ?? '') as s.SseKmsEncryptedObjectsStatus),
  };
}

function ReplicaModifications_Serialize(data: s.ReplicaModifications | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
  ]};
}
function ReplicaModifications_Parse(node: xmlP.XmlNode): s.ReplicaModifications {
  return {
    Status: node.first("Status", true, x => (x.content ?? '') as s.ReplicaModificationsStatus),
  };
}

function ExistingObjectReplication_Serialize(data: s.ExistingObjectReplication | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
  ]};
}
function ExistingObjectReplication_Parse(node: xmlP.XmlNode): s.ExistingObjectReplication {
  return {
    Status: node.first("Status", true, x => (x.content ?? '') as s.ExistingObjectReplicationStatus),
  };
}

function Destination_Serialize(data: s.Destination | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Bucket", content: data["Bucket"]?.toString()},
    {name: "Account", content: data["Account"]?.toString()},
    {name: "StorageClass", content: data["StorageClass"]?.toString()},
    {name: "AccessControlTranslation", ...AccessControlTranslation_Serialize(data["AccessControlTranslation"])},
    {name: "EncryptionConfiguration", ...EncryptionConfiguration_Serialize(data["EncryptionConfiguration"])},
    {name: "ReplicationTime", ...ReplicationTime_Serialize(data["ReplicationTime"])},
    {name: "Metrics", ...Metrics_Serialize(data["Metrics"])},
  ]};
}
function Destination_Parse(node: xmlP.XmlNode): s.Destination {
  return {
    ...node.strings({
      required: {"Bucket":true},
      optional: {"Account":true},
    }),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as s.StorageClass),
    AccessControlTranslation: node.first("AccessControlTranslation", false, AccessControlTranslation_Parse),
    EncryptionConfiguration: node.first("EncryptionConfiguration", false, EncryptionConfiguration_Parse),
    ReplicationTime: node.first("ReplicationTime", false, ReplicationTime_Parse),
    Metrics: node.first("Metrics", false, Metrics_Parse),
  };
}

function AccessControlTranslation_Serialize(data: s.AccessControlTranslation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Owner", content: data["Owner"]?.toString()},
  ]};
}
function AccessControlTranslation_Parse(node: xmlP.XmlNode): s.AccessControlTranslation {
  return {
    Owner: node.first("Owner", true, x => (x.content ?? '') as s.OwnerOverride),
  };
}

function EncryptionConfiguration_Serialize(data: s.EncryptionConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ReplicaKmsKeyID", content: data["ReplicaKmsKeyID"]?.toString()},
  ]};
}
function EncryptionConfiguration_Parse(node: xmlP.XmlNode): s.EncryptionConfiguration {
  return node.strings({
    optional: {"ReplicaKmsKeyID":true},
  });
}

function ReplicationTime_Serialize(data: s.ReplicationTime | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
    {name: "Time", ...ReplicationTimeValue_Serialize(data["Time"])},
  ]};
}
function ReplicationTime_Parse(node: xmlP.XmlNode): s.ReplicationTime {
  return {
    Status: node.first("Status", true, x => (x.content ?? '') as s.ReplicationTimeStatus),
    Time: node.first("Time", true, ReplicationTimeValue_Parse),
  };
}

function ReplicationTimeValue_Serialize(data: s.ReplicationTimeValue | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Minutes", content: data["Minutes"]?.toString()},
  ]};
}
function ReplicationTimeValue_Parse(node: xmlP.XmlNode): s.ReplicationTimeValue {
  return {
    Minutes: node.first("Minutes", false, x => parseInt(x.content ?? '0')),
  };
}

function Metrics_Serialize(data: s.Metrics | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
    {name: "EventThreshold", ...ReplicationTimeValue_Serialize(data["EventThreshold"])},
  ]};
}
function Metrics_Parse(node: xmlP.XmlNode): s.Metrics {
  return {
    Status: node.first("Status", true, x => (x.content ?? '') as s.MetricsStatus),
    EventThreshold: node.first("EventThreshold", false, ReplicationTimeValue_Parse),
  };
}

function DeleteMarkerReplication_Serialize(data: s.DeleteMarkerReplication | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
  ]};
}
function DeleteMarkerReplication_Parse(node: xmlP.XmlNode): s.DeleteMarkerReplication {
  return {
    Status: node.first("Status", false, x => (x.content ?? '') as s.DeleteMarkerReplicationStatus),
  };
}

function RequestPaymentConfiguration_Serialize(data: s.RequestPaymentConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Payer", content: data["Payer"]?.toString()},
  ]};
}

function Tagging_Serialize(data: s.Tagging | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "TagSet", children: data["TagSet"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)}))},
  ]};
}

function VersioningConfiguration_Serialize(data: s.VersioningConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "MfaDelete", content: data["MFADelete"]?.toString()},
    {name: "Status", content: data["Status"]?.toString()},
  ]};
}

function WebsiteConfiguration_Serialize(data: s.WebsiteConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ErrorDocument", ...ErrorDocument_Serialize(data["ErrorDocument"])},
    {name: "IndexDocument", ...IndexDocument_Serialize(data["IndexDocument"])},
    {name: "RedirectAllRequestsTo", ...RedirectAllRequestsTo_Serialize(data["RedirectAllRequestsTo"])},
    {name: "RoutingRules", children: data["RoutingRules"]?.map(x => ({name: "RoutingRule", ...RoutingRule_Serialize(x)}))},
  ]};
}

function ErrorDocument_Serialize(data: s.ErrorDocument | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Key", content: data["Key"]?.toString()},
  ]};
}
function ErrorDocument_Parse(node: xmlP.XmlNode): s.ErrorDocument {
  return node.strings({
    required: {"Key":true},
  });
}

function IndexDocument_Serialize(data: s.IndexDocument | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Suffix", content: data["Suffix"]?.toString()},
  ]};
}
function IndexDocument_Parse(node: xmlP.XmlNode): s.IndexDocument {
  return node.strings({
    required: {"Suffix":true},
  });
}

function RedirectAllRequestsTo_Serialize(data: s.RedirectAllRequestsTo | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HostName", content: data["HostName"]?.toString()},
    {name: "Protocol", content: data["Protocol"]?.toString()},
  ]};
}
function RedirectAllRequestsTo_Parse(node: xmlP.XmlNode): s.RedirectAllRequestsTo {
  return {
    ...node.strings({
      required: {"HostName":true},
    }),
    Protocol: node.first("Protocol", false, x => (x.content ?? '') as s.Protocol),
  };
}

function RoutingRule_Serialize(data: s.RoutingRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Condition", ...Condition_Serialize(data["Condition"])},
    {name: "Redirect", ...Redirect_Serialize(data["Redirect"])},
  ]};
}
function RoutingRule_Parse(node: xmlP.XmlNode): s.RoutingRule {
  return {
    Condition: node.first("Condition", false, Condition_Parse),
    Redirect: node.first("Redirect", true, Redirect_Parse),
  };
}

function Condition_Serialize(data: s.Condition | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HttpErrorCodeReturnedEquals", content: data["HttpErrorCodeReturnedEquals"]?.toString()},
    {name: "KeyPrefixEquals", content: data["KeyPrefixEquals"]?.toString()},
  ]};
}
function Condition_Parse(node: xmlP.XmlNode): s.Condition {
  return node.strings({
    optional: {"HttpErrorCodeReturnedEquals":true,"KeyPrefixEquals":true},
  });
}

function Redirect_Serialize(data: s.Redirect | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HostName", content: data["HostName"]?.toString()},
    {name: "HttpRedirectCode", content: data["HttpRedirectCode"]?.toString()},
    {name: "Protocol", content: data["Protocol"]?.toString()},
    {name: "ReplaceKeyPrefixWith", content: data["ReplaceKeyPrefixWith"]?.toString()},
    {name: "ReplaceKeyWith", content: data["ReplaceKeyWith"]?.toString()},
  ]};
}
function Redirect_Parse(node: xmlP.XmlNode): s.Redirect {
  return {
    ...node.strings({
      optional: {"HostName":true,"HttpRedirectCode":true,"ReplaceKeyPrefixWith":true,"ReplaceKeyWith":true},
    }),
    Protocol: node.first("Protocol", false, x => (x.content ?? '') as s.Protocol),
  };
}

function ObjectLockLegalHold_Serialize(data: s.ObjectLockLegalHold | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Status", content: data["Status"]?.toString()},
  ]};
}
function ObjectLockLegalHold_Parse(node: xmlP.XmlNode): s.ObjectLockLegalHold {
  return {
    Status: node.first("Status", false, x => (x.content ?? '') as s.ObjectLockLegalHoldStatus),
  };
}

function ObjectLockConfiguration_Serialize(data: s.ObjectLockConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ObjectLockEnabled", content: data["ObjectLockEnabled"]?.toString()},
    {name: "Rule", ...ObjectLockRule_Serialize(data["Rule"])},
  ]};
}
function ObjectLockConfiguration_Parse(node: xmlP.XmlNode): s.ObjectLockConfiguration {
  return {
    ObjectLockEnabled: node.first("ObjectLockEnabled", false, x => (x.content ?? '') as s.ObjectLockEnabled),
    Rule: node.first("Rule", false, ObjectLockRule_Parse),
  };
}

function ObjectLockRule_Serialize(data: s.ObjectLockRule | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "DefaultRetention", ...DefaultRetention_Serialize(data["DefaultRetention"])},
  ]};
}
function ObjectLockRule_Parse(node: xmlP.XmlNode): s.ObjectLockRule {
  return {
    DefaultRetention: node.first("DefaultRetention", false, DefaultRetention_Parse),
  };
}

function DefaultRetention_Serialize(data: s.DefaultRetention | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Mode", content: data["Mode"]?.toString()},
    {name: "Days", content: data["Days"]?.toString()},
    {name: "Years", content: data["Years"]?.toString()},
  ]};
}
function DefaultRetention_Parse(node: xmlP.XmlNode): s.DefaultRetention {
  return {
    Mode: node.first("Mode", false, x => (x.content ?? '') as s.ObjectLockRetentionMode),
    Days: node.first("Days", false, x => parseInt(x.content ?? '0')),
    Years: node.first("Years", false, x => parseInt(x.content ?? '0')),
  };
}

function ObjectLockRetention_Serialize(data: s.ObjectLockRetention | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Mode", content: data["Mode"]?.toString()},
    {name: "RetainUntilDate", content: cmnP.serializeDate_iso8601(data["RetainUntilDate"])},
  ]};
}
function ObjectLockRetention_Parse(node: xmlP.XmlNode): s.ObjectLockRetention {
  return {
    Mode: node.first("Mode", false, x => (x.content ?? '') as s.ObjectLockRetentionMode),
    RetainUntilDate: node.first("RetainUntilDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function PublicAccessBlockConfiguration_Serialize(data: s.PublicAccessBlockConfiguration | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "BlockPublicAcls", content: data["BlockPublicAcls"]?.toString()},
    {name: "IgnorePublicAcls", content: data["IgnorePublicAcls"]?.toString()},
    {name: "BlockPublicPolicy", content: data["BlockPublicPolicy"]?.toString()},
    {name: "RestrictPublicBuckets", content: data["RestrictPublicBuckets"]?.toString()},
  ]};
}
function PublicAccessBlockConfiguration_Parse(node: xmlP.XmlNode): s.PublicAccessBlockConfiguration {
  return {
    BlockPublicAcls: node.first("BlockPublicAcls", false, x => x.content === 'true'),
    IgnorePublicAcls: node.first("IgnorePublicAcls", false, x => x.content === 'true'),
    BlockPublicPolicy: node.first("BlockPublicPolicy", false, x => x.content === 'true'),
    RestrictPublicBuckets: node.first("RestrictPublicBuckets", false, x => x.content === 'true'),
  };
}

function RestoreRequest_Serialize(data: s.RestoreRequest | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Days", content: data["Days"]?.toString()},
    {name: "GlacierJobParameters", ...GlacierJobParameters_Serialize(data["GlacierJobParameters"])},
    {name: "Type", content: data["Type"]?.toString()},
    {name: "Tier", content: data["Tier"]?.toString()},
    {name: "Description", content: data["Description"]?.toString()},
    {name: "SelectParameters", ...SelectParameters_Serialize(data["SelectParameters"])},
    {name: "OutputLocation", ...OutputLocation_Serialize(data["OutputLocation"])},
  ]};
}

function GlacierJobParameters_Serialize(data: s.GlacierJobParameters | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Tier", content: data["Tier"]?.toString()},
  ]};
}

function SelectParameters_Serialize(data: s.SelectParameters | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "InputSerialization", ...InputSerialization_Serialize(data["InputSerialization"])},
    {name: "ExpressionType", content: data["ExpressionType"]?.toString()},
    {name: "Expression", content: data["Expression"]?.toString()},
    {name: "OutputSerialization", ...OutputSerialization_Serialize(data["OutputSerialization"])},
  ]};
}

function InputSerialization_Serialize(data: s.InputSerialization | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CSV", ...CSVInput_Serialize(data["CSV"])},
    {name: "CompressionType", content: data["CompressionType"]?.toString()},
    {name: "JSON", ...JSONInput_Serialize(data["JSON"])},
    {name: "Parquet", ...ParquetInput_Serialize(data["Parquet"])},
  ]};
}

function CSVInput_Serialize(data: s.CSVInput | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "FileHeaderInfo", content: data["FileHeaderInfo"]?.toString()},
    {name: "Comments", content: data["Comments"]?.toString()},
    {name: "QuoteEscapeCharacter", content: data["QuoteEscapeCharacter"]?.toString()},
    {name: "RecordDelimiter", content: data["RecordDelimiter"]?.toString()},
    {name: "FieldDelimiter", content: data["FieldDelimiter"]?.toString()},
    {name: "QuoteCharacter", content: data["QuoteCharacter"]?.toString()},
    {name: "AllowQuotedRecordDelimiter", content: data["AllowQuotedRecordDelimiter"]?.toString()},
  ]};
}

function JSONInput_Serialize(data: s.JSONInput | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Type", content: data["Type"]?.toString()},
  ]};
}

function ParquetInput_Serialize(data: s.ParquetInput | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [

  ]};
}

function OutputSerialization_Serialize(data: s.OutputSerialization | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "CSV", ...CSVOutput_Serialize(data["CSV"])},
    {name: "JSON", ...JSONOutput_Serialize(data["JSON"])},
  ]};
}

function CSVOutput_Serialize(data: s.CSVOutput | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "QuoteFields", content: data["QuoteFields"]?.toString()},
    {name: "QuoteEscapeCharacter", content: data["QuoteEscapeCharacter"]?.toString()},
    {name: "RecordDelimiter", content: data["RecordDelimiter"]?.toString()},
    {name: "FieldDelimiter", content: data["FieldDelimiter"]?.toString()},
    {name: "QuoteCharacter", content: data["QuoteCharacter"]?.toString()},
  ]};
}

function JSONOutput_Serialize(data: s.JSONOutput | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "RecordDelimiter", content: data["RecordDelimiter"]?.toString()},
  ]};
}

function OutputLocation_Serialize(data: s.OutputLocation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "S3", ...S3Location_Serialize(data["S3"])},
  ]};
}

function S3Location_Serialize(data: s.S3Location | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "BucketName", content: data["BucketName"]?.toString()},
    {name: "Prefix", content: data["Prefix"]?.toString()},
    {name: "Encryption", ...Encryption_Serialize(data["Encryption"])},
    {name: "CannedACL", content: data["CannedACL"]?.toString()},
    {name: "AccessControlList", children: data["AccessControlList"]?.map(x => ({name: "Grant", ...Grant_Serialize(x)}))},
    {name: "Tagging", ...Tagging_Serialize(data["Tagging"])},
    {name: "UserMetadata", children: data["UserMetadata"]?.map(x => ({name: "MetadataEntry", ...MetadataEntry_Serialize(x)}))},
    {name: "StorageClass", content: data["StorageClass"]?.toString()},
  ]};
}

function Encryption_Serialize(data: s.Encryption | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "EncryptionType", content: data["EncryptionType"]?.toString()},
    {name: "KMSKeyId", content: data["KMSKeyId"]?.toString()},
    {name: "KMSContext", content: data["KMSContext"]?.toString()},
  ]};
}

function MetadataEntry_Serialize(data: s.MetadataEntry | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Name", content: data["Name"]?.toString()},
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}

function RequestProgress_Serialize(data: s.RequestProgress | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Enabled", content: data["Enabled"]?.toString()},
  ]};
}

function ScanRange_Serialize(data: s.ScanRange | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Start", content: data["Start"]?.toString()},
    {name: "End", content: data["End"]?.toString()},
  ]};
}

function CopyObjectResult_Parse(node: xmlP.XmlNode): s.CopyObjectResult {
  return {
    ...node.strings({
      optional: {"ETag":true},
    }),
    LastModified: node.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function DeletedObject_Parse(node: xmlP.XmlNode): s.DeletedObject {
  return {
    ...node.strings({
      optional: {"Key":true,"VersionId":true,"DeleteMarkerVersionId":true},
    }),
    DeleteMarker: node.first("DeleteMarker", false, x => x.content === 'true'),
  };
}

function Error_Parse(node: xmlP.XmlNode): s.Error {
  return node.strings({
    optional: {"Key":true,"VersionId":true,"Code":true,"Message":true},
  });
}

function PolicyStatus_Parse(node: xmlP.XmlNode): s.PolicyStatus {
  return {
    IsPublic: node.first("IsPublic", false, x => x.content === 'true'),
  };
}

function Bucket_Parse(node: xmlP.XmlNode): s.Bucket {
  return {
    ...node.strings({
      optional: {"Name":true},
    }),
    CreationDate: node.first("CreationDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function MultipartUpload_Parse(node: xmlP.XmlNode): s.MultipartUpload {
  return {
    ...node.strings({
      optional: {"UploadId":true,"Key":true},
    }),
    Initiated: node.first("Initiated", false, x => xmlP.parseTimestamp(x.content)),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as s.StorageClass),
    Owner: node.first("Owner", false, Owner_Parse),
    Initiator: node.first("Initiator", false, Initiator_Parse),
  };
}

function Initiator_Parse(node: xmlP.XmlNode): s.Initiator {
  return node.strings({
    optional: {"ID":true,"DisplayName":true},
  });
}

function CommonPrefix_Parse(node: xmlP.XmlNode): s.CommonPrefix {
  return node.strings({
    optional: {"Prefix":true},
  });
}

function ObjectVersion_Parse(node: xmlP.XmlNode): s.ObjectVersion {
  return {
    ...node.strings({
      optional: {"ETag":true,"Key":true,"VersionId":true},
    }),
    Size: node.first("Size", false, x => parseInt(x.content ?? '0')),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as s.ObjectVersionStorageClass),
    IsLatest: node.first("IsLatest", false, x => x.content === 'true'),
    LastModified: node.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
    Owner: node.first("Owner", false, Owner_Parse),
  };
}

function DeleteMarkerEntry_Parse(node: xmlP.XmlNode): s.DeleteMarkerEntry {
  return {
    ...node.strings({
      optional: {"Key":true,"VersionId":true},
    }),
    Owner: node.first("Owner", false, Owner_Parse),
    IsLatest: node.first("IsLatest", false, x => x.content === 'true'),
    LastModified: node.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function _Object_Parse(node: xmlP.XmlNode): s._Object {
  return {
    ...node.strings({
      optional: {"Key":true,"ETag":true},
    }),
    LastModified: node.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
    Size: node.first("Size", false, x => parseInt(x.content ?? '0')),
    StorageClass: node.first("StorageClass", false, x => (x.content ?? '') as s.ObjectStorageClass),
    Owner: node.first("Owner", false, Owner_Parse),
  };
}

function Part_Parse(node: xmlP.XmlNode): s.Part {
  return {
    ...node.strings({
      optional: {"ETag":true},
    }),
    PartNumber: node.first("PartNumber", false, x => parseInt(x.content ?? '0')),
    LastModified: node.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
    Size: node.first("Size", false, x => parseInt(x.content ?? '0')),
  };
}

function SelectObjectContentEventStream_Parse(node: xmlP.XmlNode): s.SelectObjectContentEventStream {
  return {
    Records: node.first("Records", false, RecordsEvent_Parse),
    Stats: node.first("Stats", false, StatsEvent_Parse),
    Progress: node.first("Progress", false, ProgressEvent_Parse),
    Cont: node.first("Cont", false, ContinuationEvent_Parse),
    End: node.first("End", false, EndEvent_Parse),
  };
}

function RecordsEvent_Parse(node: xmlP.XmlNode): s.RecordsEvent {
  return {
    Payload: node.first("Payload", false, x => parseBlob(x.content) ?? new Uint8Array(0)),
  };
}

function StatsEvent_Parse(node: xmlP.XmlNode): s.StatsEvent {
  return {
    Details: node.first("Details", false, Stats_Parse),
  };
}

function Stats_Parse(node: xmlP.XmlNode): s.Stats {
  return {
    BytesScanned: node.first("BytesScanned", false, x => parseInt(x.content ?? '0')),
    BytesProcessed: node.first("BytesProcessed", false, x => parseInt(x.content ?? '0')),
    BytesReturned: node.first("BytesReturned", false, x => parseInt(x.content ?? '0')),
  };
}

function ProgressEvent_Parse(node: xmlP.XmlNode): s.ProgressEvent {
  return {
    Details: node.first("Details", false, Progress_Parse),
  };
}

function Progress_Parse(node: xmlP.XmlNode): s.Progress {
  return {
    BytesScanned: node.first("BytesScanned", false, x => parseInt(x.content ?? '0')),
    BytesProcessed: node.first("BytesProcessed", false, x => parseInt(x.content ?? '0')),
    BytesReturned: node.first("BytesReturned", false, x => parseInt(x.content ?? '0')),
  };
}

function ContinuationEvent_Parse(node: xmlP.XmlNode): s.ContinuationEvent {
  return {};
}

function EndEvent_Parse(node: xmlP.XmlNode): s.EndEvent {
  return {};
}

function CopyPartResult_Parse(node: xmlP.XmlNode): s.CopyPartResult {
  return {
    ...node.strings({
      optional: {"ETag":true},
    }),
    LastModified: node.first("LastModified", false, x => xmlP.parseTimestamp(x.content)),
  };
}
