// Autogenerated API client for: Amazon Simple Queue Service

export * from "./structs.ts";
import * as Base64 from "@std/encoding/base64";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encodeBase64(input);
}

export class SQS {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(SQS.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2012-11-05",
    "awsQueryCompatible": {},
    "endpointPrefix": "sqs",
    "jsonVersion": "1.0",
    "protocol": "json",
    "protocols": [
      "json"
    ],
    "serviceAbbreviation": "Amazon SQS",
    "serviceFullName": "Amazon Simple Queue Service",
    "serviceId": "SQS",
    "signatureVersion": "v4",
    "targetPrefix": "AmazonSQS",
    "uid": "sqs-2012-11-05"
  };

  async addPermission(
    params: s.AddPermissionRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
      Label: params["Label"],
      AWSAccountIds: params["AWSAccountIds"],
      Actions: params["Actions"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "AddPermission",
    });
    await resp.body?.cancel();
  }

  async cancelMessageMoveTask(
    params: s.CancelMessageMoveTaskRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.CancelMessageMoveTaskResult> {
    const body: jsonP.JSONObject = {
      TaskHandle: params["TaskHandle"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "CancelMessageMoveTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ApproximateNumberOfMessagesMoved": "n",
      },
    }, await resp.json());
  }

  async changeMessageVisibility(
    params: s.ChangeMessageVisibilityRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
      ReceiptHandle: params["ReceiptHandle"],
      VisibilityTimeout: params["VisibilityTimeout"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ChangeMessageVisibility",
    });
    await resp.body?.cancel();
  }

  async changeMessageVisibilityBatch(
    params: s.ChangeMessageVisibilityBatchRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.ChangeMessageVisibilityBatchResult> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
      Entries: params["Entries"]?.map(x => fromChangeMessageVisibilityBatchRequestEntry(x)),
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ChangeMessageVisibilityBatch",
    });
    return jsonP.readObj({
      required: {
        "Successful": [toChangeMessageVisibilityBatchResultEntry],
        "Failed": [toBatchResultErrorEntry],
      },
      optional: {},
    }, await resp.json());
  }

  async createQueue(
    params: s.CreateQueueRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.CreateQueueResult> {
    const body: jsonP.JSONObject = {
      QueueName: params["QueueName"],
      Attributes: params["Attributes"],
      tags: params["tags"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "CreateQueue",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "QueueUrl": "s",
      },
    }, await resp.json());
  }

  async deleteMessage(
    params: s.DeleteMessageRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
      ReceiptHandle: params["ReceiptHandle"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DeleteMessage",
    });
    await resp.body?.cancel();
  }

  async deleteMessageBatch(
    params: s.DeleteMessageBatchRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.DeleteMessageBatchResult> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
      Entries: params["Entries"]?.map(x => fromDeleteMessageBatchRequestEntry(x)),
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DeleteMessageBatch",
    });
    return jsonP.readObj({
      required: {
        "Successful": [toDeleteMessageBatchResultEntry],
        "Failed": [toBatchResultErrorEntry],
      },
      optional: {},
    }, await resp.json());
  }

  async deleteQueue(
    params: s.DeleteQueueRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "DeleteQueue",
    });
    await resp.body?.cancel();
  }

  async getQueueAttributes(
    params: s.GetQueueAttributesRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.GetQueueAttributesResult> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
      AttributeNames: params["AttributeNames"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GetQueueAttributes",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Attributes": x => jsonP.readMap(x => cmnP.readEnumReq<s.QueueAttributeName>(x), String, x),
      },
    }, await resp.json());
  }

  async getQueueUrl(
    params: s.GetQueueUrlRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.GetQueueUrlResult> {
    const body: jsonP.JSONObject = {
      QueueName: params["QueueName"],
      QueueOwnerAWSAccountId: params["QueueOwnerAWSAccountId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "GetQueueUrl",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "QueueUrl": "s",
      },
    }, await resp.json());
  }

  async listDeadLetterSourceQueues(
    params: s.ListDeadLetterSourceQueuesRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.ListDeadLetterSourceQueuesResult> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ListDeadLetterSourceQueues",
    });
    return jsonP.readObj({
      required: {
        "queueUrls": ["s"],
      },
      optional: {
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async listMessageMoveTasks(
    params: s.ListMessageMoveTasksRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.ListMessageMoveTasksResult> {
    const body: jsonP.JSONObject = {
      SourceArn: params["SourceArn"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ListMessageMoveTasks",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Results": [toListMessageMoveTasksResultEntry],
      },
    }, await resp.json());
  }

  async listQueueTags(
    params: s.ListQueueTagsRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.ListQueueTagsResult> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ListQueueTags",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async listQueues(
    params: s.ListQueuesRequest = {},
    opts: client.RequestOptions = {},
  ): Promise<s.ListQueuesResult> {
    const body: jsonP.JSONObject = {
      QueueNamePrefix: params["QueueNamePrefix"],
      NextToken: params["NextToken"],
      MaxResults: params["MaxResults"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ListQueues",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "QueueUrls": ["s"],
        "NextToken": "s",
      },
    }, await resp.json());
  }

  async purgeQueue(
    params: s.PurgeQueueRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "PurgeQueue",
    });
    await resp.body?.cancel();
  }

  async receiveMessage(
    params: s.ReceiveMessageRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.ReceiveMessageResult> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
      AttributeNames: params["AttributeNames"],
      MessageSystemAttributeNames: params["MessageSystemAttributeNames"],
      MessageAttributeNames: params["MessageAttributeNames"],
      MaxNumberOfMessages: params["MaxNumberOfMessages"],
      VisibilityTimeout: params["VisibilityTimeout"],
      WaitTimeSeconds: params["WaitTimeSeconds"],
      ReceiveRequestAttemptId: params["ReceiveRequestAttemptId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "ReceiveMessage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Messages": [toMessage],
      },
    }, await resp.json());
  }

  async removePermission(
    params: s.RemovePermissionRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
      Label: params["Label"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "RemovePermission",
    });
    await resp.body?.cancel();
  }

  async sendMessage(
    params: s.SendMessageRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.SendMessageResult> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
      MessageBody: params["MessageBody"],
      DelaySeconds: params["DelaySeconds"],
      MessageAttributes: jsonP.serializeMap(params["MessageAttributes"], x => fromMessageAttributeValue(x)),
      MessageSystemAttributes: jsonP.serializeMap(params["MessageSystemAttributes"], x => fromMessageSystemAttributeValue(x)),
      MessageDeduplicationId: params["MessageDeduplicationId"],
      MessageGroupId: params["MessageGroupId"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "SendMessage",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "MD5OfMessageBody": "s",
        "MD5OfMessageAttributes": "s",
        "MD5OfMessageSystemAttributes": "s",
        "MessageId": "s",
        "SequenceNumber": "s",
      },
    }, await resp.json());
  }

  async sendMessageBatch(
    params: s.SendMessageBatchRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.SendMessageBatchResult> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
      Entries: params["Entries"]?.map(x => fromSendMessageBatchRequestEntry(x)),
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "SendMessageBatch",
    });
    return jsonP.readObj({
      required: {
        "Successful": [toSendMessageBatchResultEntry],
        "Failed": [toBatchResultErrorEntry],
      },
      optional: {},
    }, await resp.json());
  }

  async setQueueAttributes(
    params: s.SetQueueAttributesRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
      Attributes: params["Attributes"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "SetQueueAttributes",
    });
    await resp.body?.cancel();
  }

  async startMessageMoveTask(
    params: s.StartMessageMoveTaskRequest,
    opts: client.RequestOptions = {},
  ): Promise<s.StartMessageMoveTaskResult> {
    const body: jsonP.JSONObject = {
      SourceArn: params["SourceArn"],
      DestinationArn: params["DestinationArn"],
      MaxNumberOfMessagesPerSecond: params["MaxNumberOfMessagesPerSecond"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "StartMessageMoveTask",
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "TaskHandle": "s",
      },
    }, await resp.json());
  }

  async tagQueue(
    params: s.TagQueueRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "TagQueue",
    });
    await resp.body?.cancel();
  }

  async untagQueue(
    params: s.UntagQueueRequest,
    opts: client.RequestOptions = {},
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      QueueUrl: params["QueueUrl"],
      TagKeys: params["TagKeys"],
    };
    const resp = await this.#client.performRequest({
      opts, body,
      action: "UntagQueue",
    });
    await resp.body?.cancel();
  }

}

function fromChangeMessageVisibilityBatchRequestEntry(input?: s.ChangeMessageVisibilityBatchRequestEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    ReceiptHandle: input["ReceiptHandle"],
    VisibilityTimeout: input["VisibilityTimeout"],
  }
}

function fromDeleteMessageBatchRequestEntry(input?: s.DeleteMessageBatchRequestEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    ReceiptHandle: input["ReceiptHandle"],
  }
}

function fromMessageAttributeValue(input?: s.MessageAttributeValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StringValue: input["StringValue"],
    BinaryValue: serializeBlob(input["BinaryValue"]),
    StringListValues: input["StringListValues"],
    BinaryListValues: input["BinaryListValues"]?.map(x => serializeBlob(x)),
    DataType: input["DataType"],
  }
}
function toMessageAttributeValue(root: jsonP.JSONValue): s.MessageAttributeValue {
  return jsonP.readObj({
    required: {
      "DataType": "s",
    },
    optional: {
      "StringValue": "s",
      "BinaryValue": "a",
      "StringListValues": ["s"],
      "BinaryListValues": ["a"],
    },
  }, root);
}

function fromMessageSystemAttributeValue(input?: s.MessageSystemAttributeValue | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    StringValue: input["StringValue"],
    BinaryValue: serializeBlob(input["BinaryValue"]),
    StringListValues: input["StringListValues"],
    BinaryListValues: input["BinaryListValues"]?.map(x => serializeBlob(x)),
    DataType: input["DataType"],
  }
}

function fromSendMessageBatchRequestEntry(input?: s.SendMessageBatchRequestEntry | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Id: input["Id"],
    MessageBody: input["MessageBody"],
    DelaySeconds: input["DelaySeconds"],
    MessageAttributes: jsonP.serializeMap(input["MessageAttributes"], x => fromMessageAttributeValue(x)),
    MessageSystemAttributes: jsonP.serializeMap(input["MessageSystemAttributes"], x => fromMessageSystemAttributeValue(x)),
    MessageDeduplicationId: input["MessageDeduplicationId"],
    MessageGroupId: input["MessageGroupId"],
  }
}

function toChangeMessageVisibilityBatchResultEntry(root: jsonP.JSONValue): s.ChangeMessageVisibilityBatchResultEntry {
  return jsonP.readObj({
    required: {
      "Id": "s",
    },
    optional: {},
  }, root);
}

function toBatchResultErrorEntry(root: jsonP.JSONValue): s.BatchResultErrorEntry {
  return jsonP.readObj({
    required: {
      "Id": "s",
      "SenderFault": "b",
      "Code": "s",
    },
    optional: {
      "Message": "s",
    },
  }, root);
}

function toDeleteMessageBatchResultEntry(root: jsonP.JSONValue): s.DeleteMessageBatchResultEntry {
  return jsonP.readObj({
    required: {
      "Id": "s",
    },
    optional: {},
  }, root);
}

function toListMessageMoveTasksResultEntry(root: jsonP.JSONValue): s.ListMessageMoveTasksResultEntry {
  return jsonP.readObj({
    required: {},
    optional: {
      "TaskHandle": "s",
      "Status": "s",
      "SourceArn": "s",
      "DestinationArn": "s",
      "MaxNumberOfMessagesPerSecond": "n",
      "ApproximateNumberOfMessagesMoved": "n",
      "ApproximateNumberOfMessagesToMove": "n",
      "FailureReason": "s",
      "StartedTimestamp": "n",
    },
  }, root);
}

function toMessage(root: jsonP.JSONValue): s.Message {
  return jsonP.readObj({
    required: {},
    optional: {
      "MessageId": "s",
      "ReceiptHandle": "s",
      "MD5OfBody": "s",
      "Body": "s",
      "Attributes": x => jsonP.readMap(x => cmnP.readEnumReq<s.MessageSystemAttributeName>(x), String, x),
      "MD5OfMessageAttributes": "s",
      "MessageAttributes": x => jsonP.readMap(String, toMessageAttributeValue, x),
    },
  }, root);
}

function toSendMessageBatchResultEntry(root: jsonP.JSONValue): s.SendMessageBatchResultEntry {
  return jsonP.readObj({
    required: {
      "Id": "s",
      "MessageId": "s",
      "MD5OfMessageBody": "s",
    },
    optional: {
      "MD5OfMessageAttributes": "s",
      "MD5OfMessageSystemAttributes": "s",
      "SequenceNumber": "s",
    },
  }, root);
}
