// Autogenerated API client for: Amazon Route 53

export * from "./structs.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as xmlP from "../../encoding/xml.ts";
import type * as s from "./structs.ts";

export class Route53 {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Route53.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2013-04-01",
    "endpointPrefix": "route53",
    "globalEndpoint": "route53.amazonaws.com",
    "protocol": "rest-xml",
    "serviceAbbreviation": "Route 53",
    "serviceFullName": "Amazon Route 53",
    "serviceId": "Route 53",
    "signatureVersion": "v4",
    "uid": "route53-2013-04-01"
  };

  async activateKeySigningKey(
    params: s.ActivateKeySigningKeyRequest,
  ): Promise<s.ActivateKeySigningKeyResponse> {

    const resp = await this.#client.performRequest({
      action: "ActivateKeySigningKey",
      requestUri: cmnP.encodePath`/2013-04-01/keysigningkey/${params["HostedZoneId"]}/${params["Name"]}/activate`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async associateVPCWithHostedZone(
    params: s.AssociateVPCWithHostedZoneRequest,
  ): Promise<s.AssociateVPCWithHostedZoneResponse> {
    const body = xmlP.stringify({
      name: "AssociateVPCWithHostedZoneRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "VPC", ...VPC_Serialize(params["VPC"])},
        {name: "Comment", content: params["Comment"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "AssociateVPCWithHostedZone",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/associatevpc`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async changeResourceRecordSets(
    params: s.ChangeResourceRecordSetsRequest,
  ): Promise<s.ChangeResourceRecordSetsResponse> {
    const body = xmlP.stringify({
      name: "ChangeResourceRecordSetsRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "ChangeBatch", ...ChangeBatch_Serialize(params["ChangeBatch"])},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "ChangeResourceRecordSets",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/rrset/`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async changeTagsForResource(
    params: s.ChangeTagsForResourceRequest,
  ): Promise<void> {
    const body = xmlP.stringify({
      name: "ChangeTagsForResourceRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "AddTags", children: params["AddTags"]?.map(x => ({name: "Tag", ...Tag_Serialize(x)}))},
        {name: "RemoveTagKeys", children: params["RemoveTagKeys"]?.map(x => ({name: "Key", content: x}))},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "ChangeTagsForResource",
      requestUri: cmnP.encodePath`/2013-04-01/tags/${params["ResourceType"]}/${params["ResourceId"]}`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async createHealthCheck(
    params: s.CreateHealthCheckRequest,
  ): Promise<s.CreateHealthCheckResponse> {
    const body = xmlP.stringify({
      name: "CreateHealthCheckRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "CallerReference", content: params["CallerReference"]?.toString()},
        {name: "HealthCheckConfig", ...HealthCheckConfig_Serialize(params["HealthCheckConfig"])},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "CreateHealthCheck",
      requestUri: "/2013-04-01/healthcheck",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location") ?? "",
      ...{
        HealthCheck: xml.first("HealthCheck", true, HealthCheck_Parse),
      },
    };
  }

  async createHostedZone(
    params: s.CreateHostedZoneRequest,
  ): Promise<s.CreateHostedZoneResponse> {
    const body = xmlP.stringify({
      name: "CreateHostedZoneRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "Name", content: params["Name"]?.toString()},
        {name: "VPC", ...VPC_Serialize(params["VPC"])},
        {name: "CallerReference", content: params["CallerReference"]?.toString()},
        {name: "HostedZoneConfig", ...HostedZoneConfig_Serialize(params["HostedZoneConfig"])},
        {name: "DelegationSetId", content: params["DelegationSetId"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "CreateHostedZone",
      requestUri: "/2013-04-01/hostedzone",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location") ?? "",
      ...{
        HostedZone: xml.first("HostedZone", true, HostedZone_Parse),
        ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
        DelegationSet: xml.first("DelegationSet", true, DelegationSet_Parse),
        VPC: xml.first("VPC", false, VPC_Parse),
      },
    };
  }

  async createKeySigningKey(
    params: s.CreateKeySigningKeyRequest,
  ): Promise<s.CreateKeySigningKeyResponse> {
    const body = xmlP.stringify({
      name: "CreateKeySigningKeyRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "CallerReference", content: params["CallerReference"]?.toString()},
        {name: "HostedZoneId", content: params["HostedZoneId"]?.toString()},
        {name: "KeyManagementServiceArn", content: params["KeyManagementServiceArn"]?.toString()},
        {name: "Name", content: params["Name"]?.toString()},
        {name: "Status", content: params["Status"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "CreateKeySigningKey",
      requestUri: "/2013-04-01/keysigningkey",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location") ?? "",
      ...{
        ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
        KeySigningKey: xml.first("KeySigningKey", true, KeySigningKey_Parse),
      },
    };
  }

  async createQueryLoggingConfig(
    params: s.CreateQueryLoggingConfigRequest,
  ): Promise<s.CreateQueryLoggingConfigResponse> {
    const body = xmlP.stringify({
      name: "CreateQueryLoggingConfigRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "HostedZoneId", content: params["HostedZoneId"]?.toString()},
        {name: "CloudWatchLogsLogGroupArn", content: params["CloudWatchLogsLogGroupArn"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "CreateQueryLoggingConfig",
      requestUri: "/2013-04-01/queryloggingconfig",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location") ?? "",
      ...{
        QueryLoggingConfig: xml.first("QueryLoggingConfig", true, QueryLoggingConfig_Parse),
      },
    };
  }

  async createReusableDelegationSet(
    params: s.CreateReusableDelegationSetRequest,
  ): Promise<s.CreateReusableDelegationSetResponse> {
    const body = xmlP.stringify({
      name: "CreateReusableDelegationSetRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "CallerReference", content: params["CallerReference"]?.toString()},
        {name: "HostedZoneId", content: params["HostedZoneId"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "CreateReusableDelegationSet",
      requestUri: "/2013-04-01/delegationset",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location") ?? "",
      ...{
        DelegationSet: xml.first("DelegationSet", true, DelegationSet_Parse),
      },
    };
  }

  async createTrafficPolicy(
    params: s.CreateTrafficPolicyRequest,
  ): Promise<s.CreateTrafficPolicyResponse> {
    const body = xmlP.stringify({
      name: "CreateTrafficPolicyRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "Name", content: params["Name"]?.toString()},
        {name: "Document", content: params["Document"]?.toString()},
        {name: "Comment", content: params["Comment"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "CreateTrafficPolicy",
      requestUri: "/2013-04-01/trafficpolicy",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location") ?? "",
      ...{
        TrafficPolicy: xml.first("TrafficPolicy", true, TrafficPolicy_Parse),
      },
    };
  }

  async createTrafficPolicyInstance(
    params: s.CreateTrafficPolicyInstanceRequest,
  ): Promise<s.CreateTrafficPolicyInstanceResponse> {
    const body = xmlP.stringify({
      name: "CreateTrafficPolicyInstanceRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "HostedZoneId", content: params["HostedZoneId"]?.toString()},
        {name: "Name", content: params["Name"]?.toString()},
        {name: "TTL", content: params["TTL"]?.toString()},
        {name: "TrafficPolicyId", content: params["TrafficPolicyId"]?.toString()},
        {name: "TrafficPolicyVersion", content: params["TrafficPolicyVersion"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "CreateTrafficPolicyInstance",
      requestUri: "/2013-04-01/trafficpolicyinstance",
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location") ?? "",
      ...{
        TrafficPolicyInstance: xml.first("TrafficPolicyInstance", true, TrafficPolicyInstance_Parse),
      },
    };
  }

  async createTrafficPolicyVersion(
    params: s.CreateTrafficPolicyVersionRequest,
  ): Promise<s.CreateTrafficPolicyVersionResponse> {
    const body = xmlP.stringify({
      name: "CreateTrafficPolicyVersionRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "Document", content: params["Document"]?.toString()},
        {name: "Comment", content: params["Comment"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "CreateTrafficPolicyVersion",
      requestUri: cmnP.encodePath`/2013-04-01/trafficpolicy/${params["Id"]}`,
      responseCode: 201,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Location: resp.headers.get("Location") ?? "",
      ...{
        TrafficPolicy: xml.first("TrafficPolicy", true, TrafficPolicy_Parse),
      },
    };
  }

  async createVPCAssociationAuthorization(
    params: s.CreateVPCAssociationAuthorizationRequest,
  ): Promise<s.CreateVPCAssociationAuthorizationResponse> {
    const body = xmlP.stringify({
      name: "CreateVPCAssociationAuthorizationRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "VPC", ...VPC_Serialize(params["VPC"])},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "CreateVPCAssociationAuthorization",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/authorizevpcassociation`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"HostedZoneId":true},
      }),
      VPC: xml.first("VPC", true, VPC_Parse),
    };
  }

  async deactivateKeySigningKey(
    params: s.DeactivateKeySigningKeyRequest,
  ): Promise<s.DeactivateKeySigningKeyResponse> {

    const resp = await this.#client.performRequest({
      action: "DeactivateKeySigningKey",
      requestUri: cmnP.encodePath`/2013-04-01/keysigningkey/${params["HostedZoneId"]}/${params["Name"]}/deactivate`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async deleteHealthCheck(
    params: s.DeleteHealthCheckRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      action: "DeleteHealthCheck",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2013-04-01/healthcheck/${params["HealthCheckId"]}`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteHostedZone(
    params: s.DeleteHostedZoneRequest,
  ): Promise<s.DeleteHostedZoneResponse> {

    const resp = await this.#client.performRequest({
      action: "DeleteHostedZone",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async deleteKeySigningKey(
    params: s.DeleteKeySigningKeyRequest,
  ): Promise<s.DeleteKeySigningKeyResponse> {

    const resp = await this.#client.performRequest({
      action: "DeleteKeySigningKey",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2013-04-01/keysigningkey/${params["HostedZoneId"]}/${params["Name"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async deleteQueryLoggingConfig(
    params: s.DeleteQueryLoggingConfigRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      action: "DeleteQueryLoggingConfig",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2013-04-01/queryloggingconfig/${params["Id"]}`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteReusableDelegationSet(
    params: s.DeleteReusableDelegationSetRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      action: "DeleteReusableDelegationSet",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2013-04-01/delegationset/${params["Id"]}`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteTrafficPolicy(
    params: s.DeleteTrafficPolicyRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      action: "DeleteTrafficPolicy",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2013-04-01/trafficpolicy/${params["Id"]}/${params["Version"].toString()}`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteTrafficPolicyInstance(
    params: s.DeleteTrafficPolicyInstanceRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      action: "DeleteTrafficPolicyInstance",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2013-04-01/trafficpolicyinstance/${params["Id"]}`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async deleteVPCAssociationAuthorization(
    params: s.DeleteVPCAssociationAuthorizationRequest,
  ): Promise<void> {
    const body = xmlP.stringify({
      name: "DeleteVPCAssociationAuthorizationRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "VPC", ...VPC_Serialize(params["VPC"])},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "DeleteVPCAssociationAuthorization",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/deauthorizevpcassociation`,
    });
    await resp.arrayBuffer(); // consume body without use
  }

  async disableHostedZoneDNSSEC(
    params: s.DisableHostedZoneDNSSECRequest,
  ): Promise<s.DisableHostedZoneDNSSECResponse> {

    const resp = await this.#client.performRequest({
      action: "DisableHostedZoneDNSSEC",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/disable-dnssec`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async disassociateVPCFromHostedZone(
    params: s.DisassociateVPCFromHostedZoneRequest,
  ): Promise<s.DisassociateVPCFromHostedZoneResponse> {
    const body = xmlP.stringify({
      name: "DisassociateVPCFromHostedZoneRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "VPC", ...VPC_Serialize(params["VPC"])},
        {name: "Comment", content: params["Comment"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "DisassociateVPCFromHostedZone",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/disassociatevpc`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async enableHostedZoneDNSSEC(
    params: s.EnableHostedZoneDNSSECRequest,
  ): Promise<s.EnableHostedZoneDNSSECResponse> {

    const resp = await this.#client.performRequest({
      action: "EnableHostedZoneDNSSEC",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/enable-dnssec`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async getAccountLimit(
    params: s.GetAccountLimitRequest,
  ): Promise<s.GetAccountLimitResponse> {

    const resp = await this.#client.performRequest({
      action: "GetAccountLimit",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/accountlimit/${params["Type"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Limit: xml.first("Limit", true, AccountLimit_Parse),
      Count: xml.first("Count", true, x => parseInt(x.content ?? '0')),
    };
  }

  async getChange(
    params: s.GetChangeRequest,
  ): Promise<s.GetChangeResponse> {

    const resp = await this.#client.performRequest({
      action: "GetChange",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/change/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ChangeInfo: xml.first("ChangeInfo", true, ChangeInfo_Parse),
    };
  }

  async getCheckerIpRanges(): Promise<s.GetCheckerIpRangesResponse> {
    const body = ''; // TODO: anything more appropriate when no input?
    const resp = await this.#client.performRequest({
      body,
      action: "GetCheckerIpRanges",
      method: "GET",
      requestUri: "/2013-04-01/checkeripranges",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      CheckerIpRanges: xml.getList("CheckerIpRanges", "member").map(x => x.content ?? ''),
    };
  }

  async getDNSSEC(
    params: s.GetDNSSECRequest,
  ): Promise<s.GetDNSSECResponse> {

    const resp = await this.#client.performRequest({
      action: "GetDNSSEC",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/dnssec`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Status: xml.first("Status", true, DNSSECStatus_Parse),
      KeySigningKeys: xml.getList("KeySigningKeys", "member").map(KeySigningKey_Parse),
    };
  }

  async getGeoLocation(
    params: s.GetGeoLocationRequest = {},
  ): Promise<s.GetGeoLocationResponse> {
    const query = new URLSearchParams;
    if (params["ContinentCode"] != null) query.set("continentcode", params["ContinentCode"]?.toString() ?? "");
    if (params["CountryCode"] != null) query.set("countrycode", params["CountryCode"]?.toString() ?? "");
    if (params["SubdivisionCode"] != null) query.set("subdivisioncode", params["SubdivisionCode"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "GetGeoLocation",
      method: "GET",
      requestUri: "/2013-04-01/geolocation",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      GeoLocationDetails: xml.first("GeoLocationDetails", true, GeoLocationDetails_Parse),
    };
  }

  async getHealthCheck(
    params: s.GetHealthCheckRequest,
  ): Promise<s.GetHealthCheckResponse> {

    const resp = await this.#client.performRequest({
      action: "GetHealthCheck",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/healthcheck/${params["HealthCheckId"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HealthCheck: xml.first("HealthCheck", true, HealthCheck_Parse),
    };
  }

  async getHealthCheckCount(): Promise<s.GetHealthCheckCountResponse> {
    const body = ''; // TODO: anything more appropriate when no input?
    const resp = await this.#client.performRequest({
      body,
      action: "GetHealthCheckCount",
      method: "GET",
      requestUri: "/2013-04-01/healthcheckcount",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HealthCheckCount: xml.first("HealthCheckCount", true, x => parseInt(x.content ?? '0')),
    };
  }

  async getHealthCheckLastFailureReason(
    params: s.GetHealthCheckLastFailureReasonRequest,
  ): Promise<s.GetHealthCheckLastFailureReasonResponse> {

    const resp = await this.#client.performRequest({
      action: "GetHealthCheckLastFailureReason",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/healthcheck/${params["HealthCheckId"]}/lastfailurereason`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HealthCheckObservations: xml.getList("HealthCheckObservations", "HealthCheckObservation").map(HealthCheckObservation_Parse),
    };
  }

  async getHealthCheckStatus(
    params: s.GetHealthCheckStatusRequest,
  ): Promise<s.GetHealthCheckStatusResponse> {

    const resp = await this.#client.performRequest({
      action: "GetHealthCheckStatus",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/healthcheck/${params["HealthCheckId"]}/status`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HealthCheckObservations: xml.getList("HealthCheckObservations", "HealthCheckObservation").map(HealthCheckObservation_Parse),
    };
  }

  async getHostedZone(
    params: s.GetHostedZoneRequest,
  ): Promise<s.GetHostedZoneResponse> {

    const resp = await this.#client.performRequest({
      action: "GetHostedZone",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HostedZone: xml.first("HostedZone", true, HostedZone_Parse),
      DelegationSet: xml.first("DelegationSet", false, DelegationSet_Parse),
      VPCs: xml.getList("VPCs", "VPC").map(VPC_Parse),
    };
  }

  async getHostedZoneCount(): Promise<s.GetHostedZoneCountResponse> {
    const body = ''; // TODO: anything more appropriate when no input?
    const resp = await this.#client.performRequest({
      body,
      action: "GetHostedZoneCount",
      method: "GET",
      requestUri: "/2013-04-01/hostedzonecount",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HostedZoneCount: xml.first("HostedZoneCount", true, x => parseInt(x.content ?? '0')),
    };
  }

  async getHostedZoneLimit(
    params: s.GetHostedZoneLimitRequest,
  ): Promise<s.GetHostedZoneLimitResponse> {

    const resp = await this.#client.performRequest({
      action: "GetHostedZoneLimit",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzonelimit/${params["HostedZoneId"]}/${params["Type"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Limit: xml.first("Limit", true, HostedZoneLimit_Parse),
      Count: xml.first("Count", true, x => parseInt(x.content ?? '0')),
    };
  }

  async getQueryLoggingConfig(
    params: s.GetQueryLoggingConfigRequest,
  ): Promise<s.GetQueryLoggingConfigResponse> {

    const resp = await this.#client.performRequest({
      action: "GetQueryLoggingConfig",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/queryloggingconfig/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      QueryLoggingConfig: xml.first("QueryLoggingConfig", true, QueryLoggingConfig_Parse),
    };
  }

  async getReusableDelegationSet(
    params: s.GetReusableDelegationSetRequest,
  ): Promise<s.GetReusableDelegationSetResponse> {

    const resp = await this.#client.performRequest({
      action: "GetReusableDelegationSet",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/delegationset/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      DelegationSet: xml.first("DelegationSet", true, DelegationSet_Parse),
    };
  }

  async getReusableDelegationSetLimit(
    params: s.GetReusableDelegationSetLimitRequest,
  ): Promise<s.GetReusableDelegationSetLimitResponse> {

    const resp = await this.#client.performRequest({
      action: "GetReusableDelegationSetLimit",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/reusabledelegationsetlimit/${params["DelegationSetId"]}/${params["Type"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      Limit: xml.first("Limit", true, ReusableDelegationSetLimit_Parse),
      Count: xml.first("Count", true, x => parseInt(x.content ?? '0')),
    };
  }

  async getTrafficPolicy(
    params: s.GetTrafficPolicyRequest,
  ): Promise<s.GetTrafficPolicyResponse> {

    const resp = await this.#client.performRequest({
      action: "GetTrafficPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/trafficpolicy/${params["Id"]}/${params["Version"].toString()}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficPolicy: xml.first("TrafficPolicy", true, TrafficPolicy_Parse),
    };
  }

  async getTrafficPolicyInstance(
    params: s.GetTrafficPolicyInstanceRequest,
  ): Promise<s.GetTrafficPolicyInstanceResponse> {

    const resp = await this.#client.performRequest({
      action: "GetTrafficPolicyInstance",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/trafficpolicyinstance/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficPolicyInstance: xml.first("TrafficPolicyInstance", true, TrafficPolicyInstance_Parse),
    };
  }

  async getTrafficPolicyInstanceCount(): Promise<s.GetTrafficPolicyInstanceCountResponse> {
    const body = ''; // TODO: anything more appropriate when no input?
    const resp = await this.#client.performRequest({
      body,
      action: "GetTrafficPolicyInstanceCount",
      method: "GET",
      requestUri: "/2013-04-01/trafficpolicyinstancecount",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficPolicyInstanceCount: xml.first("TrafficPolicyInstanceCount", true, x => parseInt(x.content ?? '0')),
    };
  }

  async listGeoLocations(
    params: s.ListGeoLocationsRequest = {},
  ): Promise<s.ListGeoLocationsResponse> {
    const query = new URLSearchParams;
    if (params["StartContinentCode"] != null) query.set("startcontinentcode", params["StartContinentCode"]?.toString() ?? "");
    if (params["StartCountryCode"] != null) query.set("startcountrycode", params["StartCountryCode"]?.toString() ?? "");
    if (params["StartSubdivisionCode"] != null) query.set("startsubdivisioncode", params["StartSubdivisionCode"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListGeoLocations",
      method: "GET",
      requestUri: "/2013-04-01/geolocations",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"NextContinentCode":true,"NextCountryCode":true,"NextSubdivisionCode":true},
      }),
      GeoLocationDetailsList: xml.getList("GeoLocationDetailsList", "GeoLocationDetails").map(GeoLocationDetails_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listHealthChecks(
    params: s.ListHealthChecksRequest = {},
  ): Promise<s.ListHealthChecksResponse> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListHealthChecks",
      method: "GET",
      requestUri: "/2013-04-01/healthcheck",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"Marker":true,"MaxItems":true},
        optional: {"NextMarker":true},
      }),
      HealthChecks: xml.getList("HealthChecks", "HealthCheck").map(HealthCheck_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listHostedZones(
    params: s.ListHostedZonesRequest = {},
  ): Promise<s.ListHostedZonesResponse> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    if (params["DelegationSetId"] != null) query.set("delegationsetid", params["DelegationSetId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListHostedZones",
      method: "GET",
      requestUri: "/2013-04-01/hostedzone",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"Marker":true,"NextMarker":true},
      }),
      HostedZones: xml.getList("HostedZones", "HostedZone").map(HostedZone_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listHostedZonesByName(
    params: s.ListHostedZonesByNameRequest = {},
  ): Promise<s.ListHostedZonesByNameResponse> {
    const query = new URLSearchParams;
    if (params["DNSName"] != null) query.set("dnsname", params["DNSName"]?.toString() ?? "");
    if (params["HostedZoneId"] != null) query.set("hostedzoneid", params["HostedZoneId"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListHostedZonesByName",
      method: "GET",
      requestUri: "/2013-04-01/hostedzonesbyname",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"DNSName":true,"HostedZoneId":true,"NextDNSName":true,"NextHostedZoneId":true},
      }),
      HostedZones: xml.getList("HostedZones", "HostedZone").map(HostedZone_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listHostedZonesByVPC(
    params: s.ListHostedZonesByVPCRequest,
  ): Promise<s.ListHostedZonesByVPCResponse> {
    const query = new URLSearchParams;
    query.set("vpcid", params["VPCId"]?.toString() ?? "");
    query.set("vpcregion", params["VPCRegion"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nexttoken", params["NextToken"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListHostedZonesByVPC",
      method: "GET",
      requestUri: "/2013-04-01/hostedzonesbyvpc",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"NextToken":true},
      }),
      HostedZoneSummaries: xml.getList("HostedZoneSummaries", "HostedZoneSummary").map(HostedZoneSummary_Parse),
    };
  }

  async listQueryLoggingConfigs(
    params: s.ListQueryLoggingConfigsRequest = {},
  ): Promise<s.ListQueryLoggingConfigsResponse> {
    const query = new URLSearchParams;
    if (params["HostedZoneId"] != null) query.set("hostedzoneid", params["HostedZoneId"]?.toString() ?? "");
    if (params["NextToken"] != null) query.set("nexttoken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxresults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListQueryLoggingConfigs",
      method: "GET",
      requestUri: "/2013-04-01/queryloggingconfig",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        optional: {"NextToken":true},
      }),
      QueryLoggingConfigs: xml.getList("QueryLoggingConfigs", "QueryLoggingConfig").map(QueryLoggingConfig_Parse),
    };
  }

  async listResourceRecordSets(
    params: s.ListResourceRecordSetsRequest,
  ): Promise<s.ListResourceRecordSetsResponse> {
    const query = new URLSearchParams;
    if (params["StartRecordName"] != null) query.set("name", params["StartRecordName"]?.toString() ?? "");
    if (params["StartRecordType"] != null) query.set("type", params["StartRecordType"]?.toString() ?? "");
    if (params["StartRecordIdentifier"] != null) query.set("identifier", params["StartRecordIdentifier"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListResourceRecordSets",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/rrset`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"NextRecordName":true,"NextRecordIdentifier":true},
      }),
      ResourceRecordSets: xml.getList("ResourceRecordSets", "ResourceRecordSet").map(ResourceRecordSet_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
      NextRecordType: xml.first("NextRecordType", false, x => (x.content ?? '') as s.RRType),
    };
  }

  async listReusableDelegationSets(
    params: s.ListReusableDelegationSetsRequest = {},
  ): Promise<s.ListReusableDelegationSetsResponse> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListReusableDelegationSets",
      method: "GET",
      requestUri: "/2013-04-01/delegationset",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"Marker":true,"MaxItems":true},
        optional: {"NextMarker":true},
      }),
      DelegationSets: xml.getList("DelegationSets", "DelegationSet").map(DelegationSet_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listTagsForResource(
    params: s.ListTagsForResourceRequest,
  ): Promise<s.ListTagsForResourceResponse> {

    const resp = await this.#client.performRequest({
      action: "ListTagsForResource",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/tags/${params["ResourceType"]}/${params["ResourceId"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ResourceTagSet: xml.first("ResourceTagSet", true, ResourceTagSet_Parse),
    };
  }

  async listTagsForResources(
    params: s.ListTagsForResourcesRequest,
  ): Promise<s.ListTagsForResourcesResponse> {
    const body = xmlP.stringify({
      name: "ListTagsForResourcesRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "ResourceIds", children: params["ResourceIds"]?.map(x => ({name: "ResourceId", content: x}))},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "ListTagsForResources",
      requestUri: cmnP.encodePath`/2013-04-01/tags/${params["ResourceType"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ResourceTagSets: xml.getList("ResourceTagSets", "ResourceTagSet").map(ResourceTagSet_Parse),
    };
  }

  async listTrafficPolicies(
    params: s.ListTrafficPoliciesRequest = {},
  ): Promise<s.ListTrafficPoliciesResponse> {
    const query = new URLSearchParams;
    if (params["TrafficPolicyIdMarker"] != null) query.set("trafficpolicyid", params["TrafficPolicyIdMarker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListTrafficPolicies",
      method: "GET",
      requestUri: "/2013-04-01/trafficpolicies",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"TrafficPolicyIdMarker":true,"MaxItems":true},
      }),
      TrafficPolicySummaries: xml.getList("TrafficPolicySummaries", "TrafficPolicySummary").map(TrafficPolicySummary_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listTrafficPolicyInstances(
    params: s.ListTrafficPolicyInstancesRequest = {},
  ): Promise<s.ListTrafficPolicyInstancesResponse> {
    const query = new URLSearchParams;
    if (params["HostedZoneIdMarker"] != null) query.set("hostedzoneid", params["HostedZoneIdMarker"]?.toString() ?? "");
    if (params["TrafficPolicyInstanceNameMarker"] != null) query.set("trafficpolicyinstancename", params["TrafficPolicyInstanceNameMarker"]?.toString() ?? "");
    if (params["TrafficPolicyInstanceTypeMarker"] != null) query.set("trafficpolicyinstancetype", params["TrafficPolicyInstanceTypeMarker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListTrafficPolicyInstances",
      method: "GET",
      requestUri: "/2013-04-01/trafficpolicyinstances",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"HostedZoneIdMarker":true,"TrafficPolicyInstanceNameMarker":true},
      }),
      TrafficPolicyInstances: xml.getList("TrafficPolicyInstances", "TrafficPolicyInstance").map(TrafficPolicyInstance_Parse),
      TrafficPolicyInstanceTypeMarker: xml.first("TrafficPolicyInstanceTypeMarker", false, x => (x.content ?? '') as s.RRType),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listTrafficPolicyInstancesByHostedZone(
    params: s.ListTrafficPolicyInstancesByHostedZoneRequest,
  ): Promise<s.ListTrafficPolicyInstancesByHostedZoneResponse> {
    const query = new URLSearchParams;
    query.set("id", params["HostedZoneId"]?.toString() ?? "");
    if (params["TrafficPolicyInstanceNameMarker"] != null) query.set("trafficpolicyinstancename", params["TrafficPolicyInstanceNameMarker"]?.toString() ?? "");
    if (params["TrafficPolicyInstanceTypeMarker"] != null) query.set("trafficpolicyinstancetype", params["TrafficPolicyInstanceTypeMarker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListTrafficPolicyInstancesByHostedZone",
      method: "GET",
      requestUri: "/2013-04-01/trafficpolicyinstances/hostedzone",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"TrafficPolicyInstanceNameMarker":true},
      }),
      TrafficPolicyInstances: xml.getList("TrafficPolicyInstances", "TrafficPolicyInstance").map(TrafficPolicyInstance_Parse),
      TrafficPolicyInstanceTypeMarker: xml.first("TrafficPolicyInstanceTypeMarker", false, x => (x.content ?? '') as s.RRType),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listTrafficPolicyInstancesByPolicy(
    params: s.ListTrafficPolicyInstancesByPolicyRequest,
  ): Promise<s.ListTrafficPolicyInstancesByPolicyResponse> {
    const query = new URLSearchParams;
    query.set("id", params["TrafficPolicyId"]?.toString() ?? "");
    query.set("version", params["TrafficPolicyVersion"]?.toString() ?? "");
    if (params["HostedZoneIdMarker"] != null) query.set("hostedzoneid", params["HostedZoneIdMarker"]?.toString() ?? "");
    if (params["TrafficPolicyInstanceNameMarker"] != null) query.set("trafficpolicyinstancename", params["TrafficPolicyInstanceNameMarker"]?.toString() ?? "");
    if (params["TrafficPolicyInstanceTypeMarker"] != null) query.set("trafficpolicyinstancetype", params["TrafficPolicyInstanceTypeMarker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListTrafficPolicyInstancesByPolicy",
      method: "GET",
      requestUri: "/2013-04-01/trafficpolicyinstances/trafficpolicy",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"MaxItems":true},
        optional: {"HostedZoneIdMarker":true,"TrafficPolicyInstanceNameMarker":true},
      }),
      TrafficPolicyInstances: xml.getList("TrafficPolicyInstances", "TrafficPolicyInstance").map(TrafficPolicyInstance_Parse),
      TrafficPolicyInstanceTypeMarker: xml.first("TrafficPolicyInstanceTypeMarker", false, x => (x.content ?? '') as s.RRType),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listTrafficPolicyVersions(
    params: s.ListTrafficPolicyVersionsRequest,
  ): Promise<s.ListTrafficPolicyVersionsResponse> {
    const query = new URLSearchParams;
    if (params["TrafficPolicyVersionMarker"] != null) query.set("trafficpolicyversion", params["TrafficPolicyVersionMarker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("maxitems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListTrafficPolicyVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/trafficpolicies/${params["Id"]}/versions`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"TrafficPolicyVersionMarker":true,"MaxItems":true},
      }),
      TrafficPolicies: xml.getList("TrafficPolicies", "TrafficPolicy").map(TrafficPolicy_Parse),
      IsTruncated: xml.first("IsTruncated", true, x => x.content === 'true'),
    };
  }

  async listVPCAssociationAuthorizations(
    params: s.ListVPCAssociationAuthorizationsRequest,
  ): Promise<s.ListVPCAssociationAuthorizationsResponse> {
    const query = new URLSearchParams;
    if (params["NextToken"] != null) query.set("nexttoken", params["NextToken"]?.toString() ?? "");
    if (params["MaxResults"] != null) query.set("maxresults", params["MaxResults"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListVPCAssociationAuthorizations",
      method: "GET",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["HostedZoneId"]}/authorizevpcassociation`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"HostedZoneId":true},
        optional: {"NextToken":true},
      }),
      VPCs: xml.getList("VPCs", "VPC").map(VPC_Parse),
    };
  }

  async testDNSAnswer(
    params: s.TestDNSAnswerRequest,
  ): Promise<s.TestDNSAnswerResponse> {
    const query = new URLSearchParams;
    query.set("hostedzoneid", params["HostedZoneId"]?.toString() ?? "");
    query.set("recordname", params["RecordName"]?.toString() ?? "");
    query.set("recordtype", params["RecordType"]?.toString() ?? "");
    if (params["ResolverIP"] != null) query.set("resolverip", params["ResolverIP"]?.toString() ?? "");
    if (params["EDNS0ClientSubnetIP"] != null) query.set("edns0clientsubnetip", params["EDNS0ClientSubnetIP"]?.toString() ?? "");
    if (params["EDNS0ClientSubnetMask"] != null) query.set("edns0clientsubnetmask", params["EDNS0ClientSubnetMask"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "TestDNSAnswer",
      method: "GET",
      requestUri: "/2013-04-01/testdnsanswer",
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      ...xml.strings({
        required: {"Nameserver":true,"RecordName":true,"ResponseCode":true,"Protocol":true},
      }),
      RecordType: xml.first("RecordType", true, x => (x.content ?? '') as s.RRType),
      RecordData: xml.getList("RecordData", "RecordDataEntry").map(x => x.content ?? ''),
    };
  }

  async updateHealthCheck(
    params: s.UpdateHealthCheckRequest,
  ): Promise<s.UpdateHealthCheckResponse> {
    const body = xmlP.stringify({
      name: "UpdateHealthCheckRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "HealthCheckVersion", content: params["HealthCheckVersion"]?.toString()},
        {name: "IPAddress", content: params["IPAddress"]?.toString()},
        {name: "Port", content: params["Port"]?.toString()},
        {name: "ResourcePath", content: params["ResourcePath"]?.toString()},
        {name: "FullyQualifiedDomainName", content: params["FullyQualifiedDomainName"]?.toString()},
        {name: "SearchString", content: params["SearchString"]?.toString()},
        {name: "FailureThreshold", content: params["FailureThreshold"]?.toString()},
        {name: "Inverted", content: params["Inverted"]?.toString()},
        {name: "Disabled", content: params["Disabled"]?.toString()},
        {name: "HealthThreshold", content: params["HealthThreshold"]?.toString()},
        {name: "ChildHealthChecks", children: params["ChildHealthChecks"]?.map(x => ({name: "ChildHealthCheck", content: x}))},
        {name: "EnableSNI", content: params["EnableSNI"]?.toString()},
        {name: "Regions", children: params["Regions"]?.map(x => ({name: "Region", content: x}))},
        {name: "AlarmIdentifier", ...AlarmIdentifier_Serialize(params["AlarmIdentifier"])},
        {name: "InsufficientDataHealthStatus", content: params["InsufficientDataHealthStatus"]?.toString()},
        {name: "ResetElements", children: params["ResetElements"]?.map(x => ({name: "ResettableElementName", content: x}))},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "UpdateHealthCheck",
      requestUri: cmnP.encodePath`/2013-04-01/healthcheck/${params["HealthCheckId"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HealthCheck: xml.first("HealthCheck", true, HealthCheck_Parse),
    };
  }

  async updateHostedZoneComment(
    params: s.UpdateHostedZoneCommentRequest,
  ): Promise<s.UpdateHostedZoneCommentResponse> {
    const body = xmlP.stringify({
      name: "UpdateHostedZoneCommentRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "Comment", content: params["Comment"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "UpdateHostedZoneComment",
      requestUri: cmnP.encodePath`/2013-04-01/hostedzone/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      HostedZone: xml.first("HostedZone", true, HostedZone_Parse),
    };
  }

  async updateTrafficPolicyComment(
    params: s.UpdateTrafficPolicyCommentRequest,
  ): Promise<s.UpdateTrafficPolicyCommentResponse> {
    const body = xmlP.stringify({
      name: "UpdateTrafficPolicyCommentRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "Comment", content: params["Comment"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "UpdateTrafficPolicyComment",
      requestUri: cmnP.encodePath`/2013-04-01/trafficpolicy/${params["Id"]}/${params["Version"].toString()}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficPolicy: xml.first("TrafficPolicy", true, TrafficPolicy_Parse),
    };
  }

  async updateTrafficPolicyInstance(
    params: s.UpdateTrafficPolicyInstanceRequest,
  ): Promise<s.UpdateTrafficPolicyInstanceResponse> {
    const body = xmlP.stringify({
      name: "UpdateTrafficPolicyInstanceRequest",
      attributes: {"xmlns":"https://route53.amazonaws.com/doc/2013-04-01/"},
      children: [
        {name: "TTL", content: params["TTL"]?.toString()},
        {name: "TrafficPolicyId", content: params["TrafficPolicyId"]?.toString()},
        {name: "TrafficPolicyVersion", content: params["TrafficPolicyVersion"]?.toString()},
      ]});
    const resp = await this.#client.performRequest({
      body,
      action: "UpdateTrafficPolicyInstance",
      requestUri: cmnP.encodePath`/2013-04-01/trafficpolicyinstance/${params["Id"]}`,
    });
    const xml = xmlP.readXmlResult(await resp.text());
    return {
      TrafficPolicyInstance: xml.first("TrafficPolicyInstance", true, TrafficPolicyInstance_Parse),
    };
  }

  // Resource State Waiters

  /** Checks state up to 60 times, 30 seconds apart (about 30 minutes max wait time). */
  async waitForResourceRecordSetsChanged(
    params: s.GetChangeRequest,
  ): Promise<s.GetChangeResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state ResourceRecordSetsChanged';
    for (let i = 0; i < 60; i++) {
      const resp = await this.getChange(params);
      if (resp?.ChangeInfo?.Status === "INSYNC") return resp;
      await new Promise(r => setTimeout(r, 30000));
    }
    throw new Error(errMessage);
  }

}

function VPC_Serialize(data: s.VPC | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "VPCRegion", content: data["VPCRegion"]?.toString()},
    {name: "VPCId", content: data["VPCId"]?.toString()},
  ]};
}
function VPC_Parse(node: xmlP.XmlNode): s.VPC {
  return {
    ...node.strings({
      optional: {"VPCId":true},
    }),
    VPCRegion: node.first("VPCRegion", false, x => (x.content ?? '') as s.VPCRegion),
  };
}

function ChangeBatch_Serialize(data: s.ChangeBatch | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "Changes", children: data["Changes"]?.map(x => ({name: "Change", ...Change_Serialize(x)}))},
  ]};
}

function Change_Serialize(data: s.Change | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Action", content: data["Action"]?.toString()},
    {name: "ResourceRecordSet", ...ResourceRecordSet_Serialize(data["ResourceRecordSet"])},
  ]};
}

function ResourceRecordSet_Serialize(data: s.ResourceRecordSet | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Name", content: data["Name"]?.toString()},
    {name: "Type", content: data["Type"]?.toString()},
    {name: "SetIdentifier", content: data["SetIdentifier"]?.toString()},
    {name: "Weight", content: data["Weight"]?.toString()},
    {name: "Region", content: data["Region"]?.toString()},
    {name: "GeoLocation", ...GeoLocation_Serialize(data["GeoLocation"])},
    {name: "Failover", content: data["Failover"]?.toString()},
    {name: "MultiValueAnswer", content: data["MultiValueAnswer"]?.toString()},
    {name: "TTL", content: data["TTL"]?.toString()},
    {name: "ResourceRecords", children: data["ResourceRecords"]?.map(x => ({name: "ResourceRecord", ...ResourceRecord_Serialize(x)}))},
    {name: "AliasTarget", ...AliasTarget_Serialize(data["AliasTarget"])},
    {name: "HealthCheckId", content: data["HealthCheckId"]?.toString()},
    {name: "TrafficPolicyInstanceId", content: data["TrafficPolicyInstanceId"]?.toString()},
  ]};
}
function ResourceRecordSet_Parse(node: xmlP.XmlNode): s.ResourceRecordSet {
  return {
    ...node.strings({
      required: {"Name":true},
      optional: {"SetIdentifier":true,"HealthCheckId":true,"TrafficPolicyInstanceId":true},
    }),
    Type: node.first("Type", true, x => (x.content ?? '') as s.RRType),
    Weight: node.first("Weight", false, x => parseInt(x.content ?? '0')),
    Region: node.first("Region", false, x => (x.content ?? '') as s.ResourceRecordSetRegion),
    GeoLocation: node.first("GeoLocation", false, GeoLocation_Parse),
    Failover: node.first("Failover", false, x => (x.content ?? '') as s.ResourceRecordSetFailover),
    MultiValueAnswer: node.first("MultiValueAnswer", false, x => x.content === 'true'),
    TTL: node.first("TTL", false, x => parseInt(x.content ?? '0')),
    ResourceRecords: node.getList("ResourceRecords", "ResourceRecord").map(ResourceRecord_Parse),
    AliasTarget: node.first("AliasTarget", false, AliasTarget_Parse),
  };
}

function GeoLocation_Serialize(data: s.GeoLocation | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "ContinentCode", content: data["ContinentCode"]?.toString()},
    {name: "CountryCode", content: data["CountryCode"]?.toString()},
    {name: "SubdivisionCode", content: data["SubdivisionCode"]?.toString()},
  ]};
}
function GeoLocation_Parse(node: xmlP.XmlNode): s.GeoLocation {
  return node.strings({
    optional: {"ContinentCode":true,"CountryCode":true,"SubdivisionCode":true},
  });
}

function ResourceRecord_Serialize(data: s.ResourceRecord | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function ResourceRecord_Parse(node: xmlP.XmlNode): s.ResourceRecord {
  return node.strings({
    required: {"Value":true},
  });
}

function AliasTarget_Serialize(data: s.AliasTarget | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "HostedZoneId", content: data["HostedZoneId"]?.toString()},
    {name: "DNSName", content: data["DNSName"]?.toString()},
    {name: "EvaluateTargetHealth", content: data["EvaluateTargetHealth"]?.toString()},
  ]};
}
function AliasTarget_Parse(node: xmlP.XmlNode): s.AliasTarget {
  return {
    ...node.strings({
      required: {"HostedZoneId":true,"DNSName":true},
    }),
    EvaluateTargetHealth: node.first("EvaluateTargetHealth", true, x => x.content === 'true'),
  };
}

function Tag_Serialize(data: s.Tag | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Key", content: data["Key"]?.toString()},
    {name: "Value", content: data["Value"]?.toString()},
  ]};
}
function Tag_Parse(node: xmlP.XmlNode): s.Tag {
  return node.strings({
    optional: {"Key":true,"Value":true},
  });
}

function HealthCheckConfig_Serialize(data: s.HealthCheckConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "IPAddress", content: data["IPAddress"]?.toString()},
    {name: "Port", content: data["Port"]?.toString()},
    {name: "Type", content: data["Type"]?.toString()},
    {name: "ResourcePath", content: data["ResourcePath"]?.toString()},
    {name: "FullyQualifiedDomainName", content: data["FullyQualifiedDomainName"]?.toString()},
    {name: "SearchString", content: data["SearchString"]?.toString()},
    {name: "RequestInterval", content: data["RequestInterval"]?.toString()},
    {name: "FailureThreshold", content: data["FailureThreshold"]?.toString()},
    {name: "MeasureLatency", content: data["MeasureLatency"]?.toString()},
    {name: "Inverted", content: data["Inverted"]?.toString()},
    {name: "Disabled", content: data["Disabled"]?.toString()},
    {name: "HealthThreshold", content: data["HealthThreshold"]?.toString()},
    {name: "ChildHealthChecks", children: data["ChildHealthChecks"]?.map(x => ({name: "ChildHealthCheck", content: x}))},
    {name: "EnableSNI", content: data["EnableSNI"]?.toString()},
    {name: "Regions", children: data["Regions"]?.map(x => ({name: "Region", content: x}))},
    {name: "AlarmIdentifier", ...AlarmIdentifier_Serialize(data["AlarmIdentifier"])},
    {name: "InsufficientDataHealthStatus", content: data["InsufficientDataHealthStatus"]?.toString()},
    {name: "RoutingControlArn", content: data["RoutingControlArn"]?.toString()},
  ]};
}
function HealthCheckConfig_Parse(node: xmlP.XmlNode): s.HealthCheckConfig {
  return {
    ...node.strings({
      optional: {"IPAddress":true,"ResourcePath":true,"FullyQualifiedDomainName":true,"SearchString":true,"RoutingControlArn":true},
    }),
    Port: node.first("Port", false, x => parseInt(x.content ?? '0')),
    Type: node.first("Type", true, x => (x.content ?? '') as s.HealthCheckType),
    RequestInterval: node.first("RequestInterval", false, x => parseInt(x.content ?? '0')),
    FailureThreshold: node.first("FailureThreshold", false, x => parseInt(x.content ?? '0')),
    MeasureLatency: node.first("MeasureLatency", false, x => x.content === 'true'),
    Inverted: node.first("Inverted", false, x => x.content === 'true'),
    Disabled: node.first("Disabled", false, x => x.content === 'true'),
    HealthThreshold: node.first("HealthThreshold", false, x => parseInt(x.content ?? '0')),
    ChildHealthChecks: node.getList("ChildHealthChecks", "ChildHealthCheck").map(x => x.content ?? ''),
    EnableSNI: node.first("EnableSNI", false, x => x.content === 'true'),
    Regions: node.getList("Regions", "Region").map(x => (x.content ?? '') as s.HealthCheckRegion),
    AlarmIdentifier: node.first("AlarmIdentifier", false, AlarmIdentifier_Parse),
    InsufficientDataHealthStatus: node.first("InsufficientDataHealthStatus", false, x => (x.content ?? '') as s.InsufficientDataHealthStatus),
  };
}

function AlarmIdentifier_Serialize(data: s.AlarmIdentifier | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Region", content: data["Region"]?.toString()},
    {name: "Name", content: data["Name"]?.toString()},
  ]};
}
function AlarmIdentifier_Parse(node: xmlP.XmlNode): s.AlarmIdentifier {
  return {
    ...node.strings({
      required: {"Name":true},
    }),
    Region: node.first("Region", true, x => (x.content ?? '') as s.CloudWatchRegion),
  };
}

function HostedZoneConfig_Serialize(data: s.HostedZoneConfig | undefined | null): Partial<xmlP.Node> {
  if (!data) return {};
  return {children: [
    {name: "Comment", content: data["Comment"]?.toString()},
    {name: "PrivateZone", content: data["PrivateZone"]?.toString()},
  ]};
}
function HostedZoneConfig_Parse(node: xmlP.XmlNode): s.HostedZoneConfig {
  return {
    ...node.strings({
      optional: {"Comment":true},
    }),
    PrivateZone: node.first("PrivateZone", false, x => x.content === 'true'),
  };
}

function ChangeInfo_Parse(node: xmlP.XmlNode): s.ChangeInfo {
  return {
    ...node.strings({
      required: {"Id":true},
      optional: {"Comment":true},
    }),
    Status: node.first("Status", true, x => (x.content ?? '') as s.ChangeStatus),
    SubmittedAt: node.first("SubmittedAt", true, x => xmlP.parseTimestamp(x.content)),
  };
}

function HealthCheck_Parse(node: xmlP.XmlNode): s.HealthCheck {
  return {
    ...node.strings({
      required: {"Id":true,"CallerReference":true},
    }),
    LinkedService: node.first("LinkedService", false, LinkedService_Parse),
    HealthCheckConfig: node.first("HealthCheckConfig", true, HealthCheckConfig_Parse),
    HealthCheckVersion: node.first("HealthCheckVersion", true, x => parseInt(x.content ?? '0')),
    CloudWatchAlarmConfiguration: node.first("CloudWatchAlarmConfiguration", false, CloudWatchAlarmConfiguration_Parse),
  };
}

function LinkedService_Parse(node: xmlP.XmlNode): s.LinkedService {
  return node.strings({
    optional: {"ServicePrincipal":true,"Description":true},
  });
}

function CloudWatchAlarmConfiguration_Parse(node: xmlP.XmlNode): s.CloudWatchAlarmConfiguration {
  return {
    ...node.strings({
      required: {"MetricName":true,"Namespace":true},
    }),
    EvaluationPeriods: node.first("EvaluationPeriods", true, x => parseInt(x.content ?? '0')),
    Threshold: node.first("Threshold", true, x => parseFloat(x.content ?? '0')),
    ComparisonOperator: node.first("ComparisonOperator", true, x => (x.content ?? '') as s.ComparisonOperator),
    Period: node.first("Period", true, x => parseInt(x.content ?? '0')),
    Statistic: node.first("Statistic", true, x => (x.content ?? '') as s.Statistic),
    Dimensions: node.getList("Dimensions", "Dimension").map(Dimension_Parse),
  };
}

function Dimension_Parse(node: xmlP.XmlNode): s.Dimension {
  return node.strings({
    required: {"Name":true,"Value":true},
  });
}

function HostedZone_Parse(node: xmlP.XmlNode): s.HostedZone {
  return {
    ...node.strings({
      required: {"Id":true,"Name":true,"CallerReference":true},
    }),
    Config: node.first("Config", false, HostedZoneConfig_Parse),
    ResourceRecordSetCount: node.first("ResourceRecordSetCount", false, x => parseInt(x.content ?? '0')),
    LinkedService: node.first("LinkedService", false, LinkedService_Parse),
  };
}

function DelegationSet_Parse(node: xmlP.XmlNode): s.DelegationSet {
  return {
    ...node.strings({
      optional: {"Id":true,"CallerReference":true},
    }),
    NameServers: node.getList("NameServers", "NameServer").map(x => x.content ?? ''),
  };
}

function KeySigningKey_Parse(node: xmlP.XmlNode): s.KeySigningKey {
  return {
    ...node.strings({
      optional: {"Name":true,"KmsArn":true,"SigningAlgorithmMnemonic":true,"DigestAlgorithmMnemonic":true,"DigestValue":true,"PublicKey":true,"DSRecord":true,"DNSKEYRecord":true,"Status":true,"StatusMessage":true},
    }),
    Flag: node.first("Flag", false, x => parseInt(x.content ?? '0')),
    SigningAlgorithmType: node.first("SigningAlgorithmType", false, x => parseInt(x.content ?? '0')),
    DigestAlgorithmType: node.first("DigestAlgorithmType", false, x => parseInt(x.content ?? '0')),
    KeyTag: node.first("KeyTag", false, x => parseInt(x.content ?? '0')),
    CreatedDate: node.first("CreatedDate", false, x => xmlP.parseTimestamp(x.content)),
    LastModifiedDate: node.first("LastModifiedDate", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function QueryLoggingConfig_Parse(node: xmlP.XmlNode): s.QueryLoggingConfig {
  return node.strings({
    required: {"Id":true,"HostedZoneId":true,"CloudWatchLogsLogGroupArn":true},
  });
}

function TrafficPolicy_Parse(node: xmlP.XmlNode): s.TrafficPolicy {
  return {
    ...node.strings({
      required: {"Id":true,"Name":true,"Document":true},
      optional: {"Comment":true},
    }),
    Version: node.first("Version", true, x => parseInt(x.content ?? '0')),
    Type: node.first("Type", true, x => (x.content ?? '') as s.RRType),
  };
}

function TrafficPolicyInstance_Parse(node: xmlP.XmlNode): s.TrafficPolicyInstance {
  return {
    ...node.strings({
      required: {"Id":true,"HostedZoneId":true,"Name":true,"State":true,"Message":true,"TrafficPolicyId":true},
    }),
    TTL: node.first("TTL", true, x => parseInt(x.content ?? '0')),
    TrafficPolicyVersion: node.first("TrafficPolicyVersion", true, x => parseInt(x.content ?? '0')),
    TrafficPolicyType: node.first("TrafficPolicyType", true, x => (x.content ?? '') as s.RRType),
  };
}

function AccountLimit_Parse(node: xmlP.XmlNode): s.AccountLimit {
  return {
    Type: node.first("Type", true, x => (x.content ?? '') as s.AccountLimitType),
    Value: node.first("Value", true, x => parseInt(x.content ?? '0')),
  };
}

function DNSSECStatus_Parse(node: xmlP.XmlNode): s.DNSSECStatus {
  return node.strings({
    optional: {"ServeSignature":true,"StatusMessage":true},
  });
}

function GeoLocationDetails_Parse(node: xmlP.XmlNode): s.GeoLocationDetails {
  return node.strings({
    optional: {"ContinentCode":true,"ContinentName":true,"CountryCode":true,"CountryName":true,"SubdivisionCode":true,"SubdivisionName":true},
  });
}

function HealthCheckObservation_Parse(node: xmlP.XmlNode): s.HealthCheckObservation {
  return {
    ...node.strings({
      optional: {"IPAddress":true},
    }),
    Region: node.first("Region", false, x => (x.content ?? '') as s.HealthCheckRegion),
    StatusReport: node.first("StatusReport", false, StatusReport_Parse),
  };
}

function StatusReport_Parse(node: xmlP.XmlNode): s.StatusReport {
  return {
    ...node.strings({
      optional: {"Status":true},
    }),
    CheckedTime: node.first("CheckedTime", false, x => xmlP.parseTimestamp(x.content)),
  };
}

function HostedZoneLimit_Parse(node: xmlP.XmlNode): s.HostedZoneLimit {
  return {
    Type: node.first("Type", true, x => (x.content ?? '') as s.HostedZoneLimitType),
    Value: node.first("Value", true, x => parseInt(x.content ?? '0')),
  };
}

function ReusableDelegationSetLimit_Parse(node: xmlP.XmlNode): s.ReusableDelegationSetLimit {
  return {
    Type: node.first("Type", true, x => (x.content ?? '') as s.ReusableDelegationSetLimitType),
    Value: node.first("Value", true, x => parseInt(x.content ?? '0')),
  };
}

function HostedZoneSummary_Parse(node: xmlP.XmlNode): s.HostedZoneSummary {
  return {
    ...node.strings({
      required: {"HostedZoneId":true,"Name":true},
    }),
    Owner: node.first("Owner", true, HostedZoneOwner_Parse),
  };
}

function HostedZoneOwner_Parse(node: xmlP.XmlNode): s.HostedZoneOwner {
  return node.strings({
    optional: {"OwningAccount":true,"OwningService":true},
  });
}

function ResourceTagSet_Parse(node: xmlP.XmlNode): s.ResourceTagSet {
  return {
    ...node.strings({
      optional: {"ResourceId":true},
    }),
    ResourceType: node.first("ResourceType", false, x => (x.content ?? '') as s.TagResourceType),
    Tags: node.getList("Tags", "Tag").map(Tag_Parse),
  };
}

function TrafficPolicySummary_Parse(node: xmlP.XmlNode): s.TrafficPolicySummary {
  return {
    ...node.strings({
      required: {"Id":true,"Name":true},
    }),
    Type: node.first("Type", true, x => (x.content ?? '') as s.RRType),
    LatestVersion: node.first("LatestVersion", true, x => parseInt(x.content ?? '0')),
    TrafficPolicyCount: node.first("TrafficPolicyCount", true, x => parseInt(x.content ?? '0')),
  };
}
