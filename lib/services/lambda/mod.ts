// Autogenerated API client for: AWS Lambda

export * from "./structs.ts";
import * as Base64 from "https://deno.land/std@0.105.0/encoding/base64.ts";
import * as client from "../../client/common.ts";
import * as cmnP from "../../encoding/common.ts";
import * as jsonP from "../../encoding/json.ts";
import type * as s from "./structs.ts";
function serializeBlob(input: string | Uint8Array | null | undefined) {
  if (input == null) return input;
  return Base64.encode(input);
}

export class Lambda {
  #client: client.ServiceClient;
  constructor(apiFactory: client.ApiFactory) {
    this.#client = apiFactory.buildServiceClient(Lambda.ApiMetadata);
  }

  static ApiMetadata: client.ApiMetadata = {
    "apiVersion": "2015-03-31",
    "endpointPrefix": "lambda",
    "protocol": "rest-json",
    "serviceFullName": "AWS Lambda",
    "serviceId": "Lambda",
    "signatureVersion": "v4",
    "uid": "lambda-2015-03-31"
  };

  async addLayerVersionPermission(
    params: s.AddLayerVersionPermissionRequest,
  ): Promise<s.AddLayerVersionPermissionResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      StatementId: params["StatementId"],
      Action: params["Action"],
      Principal: params["Principal"],
      OrganizationId: params["OrganizationId"],
    };
    if (params["RevisionId"] != null) query.set("RevisionId", params["RevisionId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query, body,
      action: "AddLayerVersionPermission",
      requestUri: cmnP.encodePath`/2018-10-31/layers/${params["LayerName"]}/versions/${params["VersionNumber"].toString()}/policy`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Statement": "s",
        "RevisionId": "s",
      },
    }, await resp.json());
  }

  async addPermission(
    params: s.AddPermissionRequest,
  ): Promise<s.AddPermissionResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      StatementId: params["StatementId"],
      Action: params["Action"],
      Principal: params["Principal"],
      SourceArn: params["SourceArn"],
      SourceAccount: params["SourceAccount"],
      EventSourceToken: params["EventSourceToken"],
      RevisionId: params["RevisionId"],
    };
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query, body,
      action: "AddPermission",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/policy`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Statement": "s",
      },
    }, await resp.json());
  }

  async createAlias(
    params: s.CreateAliasRequest,
  ): Promise<s.AliasConfiguration> {
    const body: jsonP.JSONObject = {
      Name: params["Name"],
      FunctionVersion: params["FunctionVersion"],
      Description: params["Description"],
      RoutingConfig: fromAliasRoutingConfiguration(params["RoutingConfig"]),
    };
    const resp = await this.#client.performRequest({
      body,
      action: "CreateAlias",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/aliases`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AliasArn": "s",
        "Name": "s",
        "FunctionVersion": "s",
        "Description": "s",
        "RoutingConfig": toAliasRoutingConfiguration,
        "RevisionId": "s",
      },
    }, await resp.json());
  }

  async createCodeSigningConfig(
    params: s.CreateCodeSigningConfigRequest,
  ): Promise<s.CreateCodeSigningConfigResponse> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
      AllowedPublishers: fromAllowedPublishers(params["AllowedPublishers"]),
      CodeSigningPolicies: fromCodeSigningPolicies(params["CodeSigningPolicies"]),
    };
    const resp = await this.#client.performRequest({
      body,
      action: "CreateCodeSigningConfig",
      requestUri: "/2020-04-22/code-signing-configs/",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {
        "CodeSigningConfig": toCodeSigningConfig,
      },
      optional: {},
    }, await resp.json());
  }

  async createEventSourceMapping(
    params: s.CreateEventSourceMappingRequest,
  ): Promise<s.EventSourceMappingConfiguration> {
    const body: jsonP.JSONObject = {
      EventSourceArn: params["EventSourceArn"],
      FunctionName: params["FunctionName"],
      Enabled: params["Enabled"],
      BatchSize: params["BatchSize"],
      MaximumBatchingWindowInSeconds: params["MaximumBatchingWindowInSeconds"],
      ParallelizationFactor: params["ParallelizationFactor"],
      StartingPosition: params["StartingPosition"],
      StartingPositionTimestamp: jsonP.serializeDate_unixTimestamp(params["StartingPositionTimestamp"]),
      DestinationConfig: fromDestinationConfig(params["DestinationConfig"]),
      MaximumRecordAgeInSeconds: params["MaximumRecordAgeInSeconds"],
      BisectBatchOnFunctionError: params["BisectBatchOnFunctionError"],
      MaximumRetryAttempts: params["MaximumRetryAttempts"],
      TumblingWindowInSeconds: params["TumblingWindowInSeconds"],
      Topics: params["Topics"],
      Queues: params["Queues"],
      SourceAccessConfigurations: params["SourceAccessConfigurations"]?.map(x => fromSourceAccessConfiguration(x)),
      SelfManagedEventSource: fromSelfManagedEventSource(params["SelfManagedEventSource"]),
      FunctionResponseTypes: params["FunctionResponseTypes"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "CreateEventSourceMapping",
      requestUri: "/2015-03-31/event-source-mappings/",
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UUID": "s",
        "StartingPosition": (x: jsonP.JSONValue) => cmnP.readEnum<s.EventSourcePosition>(x),
        "StartingPositionTimestamp": "d",
        "BatchSize": "n",
        "MaximumBatchingWindowInSeconds": "n",
        "ParallelizationFactor": "n",
        "EventSourceArn": "s",
        "FunctionArn": "s",
        "LastModified": "d",
        "LastProcessingResult": "s",
        "State": "s",
        "StateTransitionReason": "s",
        "DestinationConfig": toDestinationConfig,
        "Topics": ["s"],
        "Queues": ["s"],
        "SourceAccessConfigurations": [toSourceAccessConfiguration],
        "SelfManagedEventSource": toSelfManagedEventSource,
        "MaximumRecordAgeInSeconds": "n",
        "BisectBatchOnFunctionError": "b",
        "MaximumRetryAttempts": "n",
        "TumblingWindowInSeconds": "n",
        "FunctionResponseTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.FunctionResponseType>(x)],
      },
    }, await resp.json());
  }

  async createFunction(
    params: s.CreateFunctionRequest,
  ): Promise<s.FunctionConfiguration> {
    const body: jsonP.JSONObject = {
      FunctionName: params["FunctionName"],
      Runtime: params["Runtime"],
      Role: params["Role"],
      Handler: params["Handler"],
      Code: fromFunctionCode(params["Code"]),
      Description: params["Description"],
      Timeout: params["Timeout"],
      MemorySize: params["MemorySize"],
      Publish: params["Publish"],
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
      PackageType: params["PackageType"],
      DeadLetterConfig: fromDeadLetterConfig(params["DeadLetterConfig"]),
      Environment: fromEnvironment(params["Environment"]),
      KMSKeyArn: params["KMSKeyArn"],
      TracingConfig: fromTracingConfig(params["TracingConfig"]),
      Tags: params["Tags"],
      Layers: params["Layers"],
      FileSystemConfigs: params["FileSystemConfigs"]?.map(x => fromFileSystemConfig(x)),
      ImageConfig: fromImageConfig(params["ImageConfig"]),
      CodeSigningConfigArn: params["CodeSigningConfigArn"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "CreateFunction",
      requestUri: "/2015-03-31/functions",
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FunctionName": "s",
        "FunctionArn": "s",
        "Runtime": (x: jsonP.JSONValue) => cmnP.readEnum<s.Runtime>(x),
        "Role": "s",
        "Handler": "s",
        "CodeSize": "n",
        "Description": "s",
        "Timeout": "n",
        "MemorySize": "n",
        "LastModified": "s",
        "CodeSha256": "s",
        "Version": "s",
        "VpcConfig": toVpcConfigResponse,
        "DeadLetterConfig": toDeadLetterConfig,
        "Environment": toEnvironmentResponse,
        "KMSKeyArn": "s",
        "TracingConfig": toTracingConfigResponse,
        "MasterArn": "s",
        "RevisionId": "s",
        "Layers": [toLayer],
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.State>(x),
        "StateReason": "s",
        "StateReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.StateReasonCode>(x),
        "LastUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.LastUpdateStatus>(x),
        "LastUpdateStatusReason": "s",
        "LastUpdateStatusReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LastUpdateStatusReasonCode>(x),
        "FileSystemConfigs": [toFileSystemConfig],
        "PackageType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageType>(x),
        "ImageConfigResponse": toImageConfigResponse,
        "SigningProfileVersionArn": "s",
        "SigningJobArn": "s",
      },
    }, await resp.json());
  }

  async deleteAlias(
    params: s.DeleteAliasRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      action: "DeleteAlias",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/aliases/${params["Name"]}`,
      responseCode: 204,
    });
  }

  async deleteCodeSigningConfig(
    params: s.DeleteCodeSigningConfigRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      action: "DeleteCodeSigningConfig",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-04-22/code-signing-configs/${params["CodeSigningConfigArn"]}`,
      responseCode: 204,
    });
  }

  async deleteEventSourceMapping(
    params: s.DeleteEventSourceMappingRequest,
  ): Promise<s.EventSourceMappingConfiguration> {

    const resp = await this.#client.performRequest({
      action: "DeleteEventSourceMapping",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2015-03-31/event-source-mappings/${params["UUID"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UUID": "s",
        "StartingPosition": (x: jsonP.JSONValue) => cmnP.readEnum<s.EventSourcePosition>(x),
        "StartingPositionTimestamp": "d",
        "BatchSize": "n",
        "MaximumBatchingWindowInSeconds": "n",
        "ParallelizationFactor": "n",
        "EventSourceArn": "s",
        "FunctionArn": "s",
        "LastModified": "d",
        "LastProcessingResult": "s",
        "State": "s",
        "StateTransitionReason": "s",
        "DestinationConfig": toDestinationConfig,
        "Topics": ["s"],
        "Queues": ["s"],
        "SourceAccessConfigurations": [toSourceAccessConfiguration],
        "SelfManagedEventSource": toSelfManagedEventSource,
        "MaximumRecordAgeInSeconds": "n",
        "BisectBatchOnFunctionError": "b",
        "MaximumRetryAttempts": "n",
        "TumblingWindowInSeconds": "n",
        "FunctionResponseTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.FunctionResponseType>(x)],
      },
    }, await resp.json());
  }

  async deleteFunction(
    params: s.DeleteFunctionRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "DeleteFunction",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}`,
      responseCode: 204,
    });
  }

  async deleteFunctionCodeSigningConfig(
    params: s.DeleteFunctionCodeSigningConfigRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      action: "DeleteFunctionCodeSigningConfig",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2020-06-30/functions/${params["FunctionName"]}/code-signing-config`,
      responseCode: 204,
    });
  }

  async deleteFunctionConcurrency(
    params: s.DeleteFunctionConcurrencyRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      action: "DeleteFunctionConcurrency",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-10-31/functions/${params["FunctionName"]}/concurrency`,
      responseCode: 204,
    });
  }

  async deleteFunctionEventInvokeConfig(
    params: s.DeleteFunctionEventInvokeConfigRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "DeleteFunctionEventInvokeConfig",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2019-09-25/functions/${params["FunctionName"]}/event-invoke-config`,
      responseCode: 204,
    });
  }

  async deleteLayerVersion(
    params: s.DeleteLayerVersionRequest,
  ): Promise<void> {

    const resp = await this.#client.performRequest({
      action: "DeleteLayerVersion",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2018-10-31/layers/${params["LayerName"]}/versions/${params["VersionNumber"].toString()}`,
      responseCode: 204,
    });
  }

  async deleteProvisionedConcurrencyConfig(
    params: s.DeleteProvisionedConcurrencyConfigRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "DeleteProvisionedConcurrencyConfig",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2019-09-30/functions/${params["FunctionName"]}/provisioned-concurrency`,
      responseCode: 204,
    });
  }

  async getAccountSettings(): Promise<s.GetAccountSettingsResponse> {
    const body: jsonP.JSONObject = {};
    const resp = await this.#client.performRequest({
      body,
      action: "GetAccountSettings",
      method: "GET",
      requestUri: "/2016-08-19/account-settings/",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AccountLimit": toAccountLimit,
        "AccountUsage": toAccountUsage,
      },
    }, await resp.json());
  }

  async getAlias(
    params: s.GetAliasRequest,
  ): Promise<s.AliasConfiguration> {

    const resp = await this.#client.performRequest({
      action: "GetAlias",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/aliases/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AliasArn": "s",
        "Name": "s",
        "FunctionVersion": "s",
        "Description": "s",
        "RoutingConfig": toAliasRoutingConfiguration,
        "RevisionId": "s",
      },
    }, await resp.json());
  }

  async getCodeSigningConfig(
    params: s.GetCodeSigningConfigRequest,
  ): Promise<s.GetCodeSigningConfigResponse> {

    const resp = await this.#client.performRequest({
      action: "GetCodeSigningConfig",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-04-22/code-signing-configs/${params["CodeSigningConfigArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "CodeSigningConfig": toCodeSigningConfig,
      },
      optional: {},
    }, await resp.json());
  }

  async getEventSourceMapping(
    params: s.GetEventSourceMappingRequest,
  ): Promise<s.EventSourceMappingConfiguration> {

    const resp = await this.#client.performRequest({
      action: "GetEventSourceMapping",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-03-31/event-source-mappings/${params["UUID"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UUID": "s",
        "StartingPosition": (x: jsonP.JSONValue) => cmnP.readEnum<s.EventSourcePosition>(x),
        "StartingPositionTimestamp": "d",
        "BatchSize": "n",
        "MaximumBatchingWindowInSeconds": "n",
        "ParallelizationFactor": "n",
        "EventSourceArn": "s",
        "FunctionArn": "s",
        "LastModified": "d",
        "LastProcessingResult": "s",
        "State": "s",
        "StateTransitionReason": "s",
        "DestinationConfig": toDestinationConfig,
        "Topics": ["s"],
        "Queues": ["s"],
        "SourceAccessConfigurations": [toSourceAccessConfiguration],
        "SelfManagedEventSource": toSelfManagedEventSource,
        "MaximumRecordAgeInSeconds": "n",
        "BisectBatchOnFunctionError": "b",
        "MaximumRetryAttempts": "n",
        "TumblingWindowInSeconds": "n",
        "FunctionResponseTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.FunctionResponseType>(x)],
      },
    }, await resp.json());
  }

  async getFunction(
    params: s.GetFunctionRequest,
  ): Promise<s.GetFunctionResponse> {
    const query = new URLSearchParams;
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "GetFunction",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Configuration": toFunctionConfiguration,
        "Code": toFunctionCodeLocation,
        "Tags": x => jsonP.readMap(String, String, x),
        "Concurrency": toConcurrency,
      },
    }, await resp.json());
  }

  async getFunctionCodeSigningConfig(
    params: s.GetFunctionCodeSigningConfigRequest,
  ): Promise<s.GetFunctionCodeSigningConfigResponse> {

    const resp = await this.#client.performRequest({
      action: "GetFunctionCodeSigningConfig",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-06-30/functions/${params["FunctionName"]}/code-signing-config`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "CodeSigningConfigArn": "s",
        "FunctionName": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async getFunctionConcurrency(
    params: s.GetFunctionConcurrencyRequest,
  ): Promise<s.GetFunctionConcurrencyResponse> {

    const resp = await this.#client.performRequest({
      action: "GetFunctionConcurrency",
      method: "GET",
      requestUri: cmnP.encodePath`/2019-09-30/functions/${params["FunctionName"]}/concurrency`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReservedConcurrentExecutions": "n",
      },
    }, await resp.json());
  }

  async getFunctionConfiguration(
    params: s.GetFunctionConfigurationRequest,
  ): Promise<s.FunctionConfiguration> {
    const query = new URLSearchParams;
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "GetFunctionConfiguration",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/configuration`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FunctionName": "s",
        "FunctionArn": "s",
        "Runtime": (x: jsonP.JSONValue) => cmnP.readEnum<s.Runtime>(x),
        "Role": "s",
        "Handler": "s",
        "CodeSize": "n",
        "Description": "s",
        "Timeout": "n",
        "MemorySize": "n",
        "LastModified": "s",
        "CodeSha256": "s",
        "Version": "s",
        "VpcConfig": toVpcConfigResponse,
        "DeadLetterConfig": toDeadLetterConfig,
        "Environment": toEnvironmentResponse,
        "KMSKeyArn": "s",
        "TracingConfig": toTracingConfigResponse,
        "MasterArn": "s",
        "RevisionId": "s",
        "Layers": [toLayer],
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.State>(x),
        "StateReason": "s",
        "StateReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.StateReasonCode>(x),
        "LastUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.LastUpdateStatus>(x),
        "LastUpdateStatusReason": "s",
        "LastUpdateStatusReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LastUpdateStatusReasonCode>(x),
        "FileSystemConfigs": [toFileSystemConfig],
        "PackageType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageType>(x),
        "ImageConfigResponse": toImageConfigResponse,
        "SigningProfileVersionArn": "s",
        "SigningJobArn": "s",
      },
    }, await resp.json());
  }

  async getFunctionEventInvokeConfig(
    params: s.GetFunctionEventInvokeConfigRequest,
  ): Promise<s.FunctionEventInvokeConfig> {
    const query = new URLSearchParams;
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "GetFunctionEventInvokeConfig",
      method: "GET",
      requestUri: cmnP.encodePath`/2019-09-25/functions/${params["FunctionName"]}/event-invoke-config`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LastModified": "d",
        "FunctionArn": "s",
        "MaximumRetryAttempts": "n",
        "MaximumEventAgeInSeconds": "n",
        "DestinationConfig": toDestinationConfig,
      },
    }, await resp.json());
  }

  async getLayerVersion(
    params: s.GetLayerVersionRequest,
  ): Promise<s.GetLayerVersionResponse> {

    const resp = await this.#client.performRequest({
      action: "GetLayerVersion",
      method: "GET",
      requestUri: cmnP.encodePath`/2018-10-31/layers/${params["LayerName"]}/versions/${params["VersionNumber"].toString()}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Content": toLayerVersionContentOutput,
        "LayerArn": "s",
        "LayerVersionArn": "s",
        "Description": "s",
        "CreatedDate": "s",
        "Version": "n",
        "CompatibleRuntimes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Runtime>(x)],
        "LicenseInfo": "s",
      },
    }, await resp.json());
  }

  async getLayerVersionByArn(
    params: s.GetLayerVersionByArnRequest,
  ): Promise<s.GetLayerVersionResponse> {
    const query = new URLSearchParams;
    query.set("Arn", params["Arn"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "GetLayerVersionByArn",
      method: "GET",
      requestUri: "/2018-10-31/layers?find=LayerVersion",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Content": toLayerVersionContentOutput,
        "LayerArn": "s",
        "LayerVersionArn": "s",
        "Description": "s",
        "CreatedDate": "s",
        "Version": "n",
        "CompatibleRuntimes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Runtime>(x)],
        "LicenseInfo": "s",
      },
    }, await resp.json());
  }

  async getLayerVersionPolicy(
    params: s.GetLayerVersionPolicyRequest,
  ): Promise<s.GetLayerVersionPolicyResponse> {

    const resp = await this.#client.performRequest({
      action: "GetLayerVersionPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/2018-10-31/layers/${params["LayerName"]}/versions/${params["VersionNumber"].toString()}/policy`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Policy": "s",
        "RevisionId": "s",
      },
    }, await resp.json());
  }

  async getPolicy(
    params: s.GetPolicyRequest,
  ): Promise<s.GetPolicyResponse> {
    const query = new URLSearchParams;
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "GetPolicy",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/policy`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Policy": "s",
        "RevisionId": "s",
      },
    }, await resp.json());
  }

  async getProvisionedConcurrencyConfig(
    params: s.GetProvisionedConcurrencyConfigRequest,
  ): Promise<s.GetProvisionedConcurrencyConfigResponse> {
    const query = new URLSearchParams;
    query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "GetProvisionedConcurrencyConfig",
      method: "GET",
      requestUri: cmnP.encodePath`/2019-09-30/functions/${params["FunctionName"]}/provisioned-concurrency`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RequestedProvisionedConcurrentExecutions": "n",
        "AvailableProvisionedConcurrentExecutions": "n",
        "AllocatedProvisionedConcurrentExecutions": "n",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProvisionedConcurrencyStatusEnum>(x),
        "StatusReason": "s",
        "LastModified": "s",
      },
    }, await resp.json());
  }

  async invoke(
    params: s.InvocationRequest,
  ): Promise<s.InvocationResponse> {
    const body = typeof params["Payload"] === 'string' ? new TextEncoder().encode(params["Payload"]) : params["Payload"];
    const headers = new Headers;
    const query = new URLSearchParams;
    if (params["InvocationType"] != null) headers.append("X-Amz-Invocation-Type", params["InvocationType"]);
    if (params["LogType"] != null) headers.append("X-Amz-Log-Type", params["LogType"]);
    if (params["ClientContext"] != null) headers.append("X-Amz-Client-Context", params["ClientContext"]);
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      headers, query, body,
      action: "Invoke",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/invocations`,
    });
    return {
      StatusCode: resp.status,
      FunctionError: resp.headers.get("X-Amz-Function-Error"),
      LogResult: resp.headers.get("X-Amz-Log-Result"),
      ExecutedVersion: resp.headers.get("X-Amz-Executed-Version"),
      Payload: new Uint8Array(await resp.arrayBuffer()), // TODO: maybe allow proper body streaming,
    };
  }

  async invokeAsync(
    params: s.InvokeAsyncRequest,
  ): Promise<s.InvokeAsyncResponse> {
    const body = typeof params["InvokeArgs"] === 'string' ? new TextEncoder().encode(params["InvokeArgs"]) : params["InvokeArgs"];
    const resp = await this.#client.performRequest({
      body,
      action: "InvokeAsync",
      requestUri: cmnP.encodePath`/2014-11-13/functions/${params["FunctionName"]}/invoke-async/`,
      responseCode: 202,
    });
    return {
      Status: resp.status,
      ...jsonP.readObj({
        required: {},
        optional: {},
      }, await resp.json()),
    };
  }

  async listAliases(
    params: s.ListAliasesRequest,
  ): Promise<s.ListAliasesResponse> {
    const query = new URLSearchParams;
    if (params["FunctionVersion"] != null) query.set("FunctionVersion", params["FunctionVersion"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListAliases",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/aliases`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "Aliases": [toAliasConfiguration],
      },
    }, await resp.json());
  }

  async listCodeSigningConfigs(
    params: s.ListCodeSigningConfigsRequest = {},
  ): Promise<s.ListCodeSigningConfigsResponse> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListCodeSigningConfigs",
      method: "GET",
      requestUri: "/2020-04-22/code-signing-configs/",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "CodeSigningConfigs": [toCodeSigningConfig],
      },
    }, await resp.json());
  }

  async listEventSourceMappings(
    params: s.ListEventSourceMappingsRequest = {},
  ): Promise<s.ListEventSourceMappingsResponse> {
    const query = new URLSearchParams;
    if (params["EventSourceArn"] != null) query.set("EventSourceArn", params["EventSourceArn"]?.toString() ?? "");
    if (params["FunctionName"] != null) query.set("FunctionName", params["FunctionName"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListEventSourceMappings",
      method: "GET",
      requestUri: "/2015-03-31/event-source-mappings/",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "EventSourceMappings": [toEventSourceMappingConfiguration],
      },
    }, await resp.json());
  }

  async listFunctionEventInvokeConfigs(
    params: s.ListFunctionEventInvokeConfigsRequest,
  ): Promise<s.ListFunctionEventInvokeConfigsResponse> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListFunctionEventInvokeConfigs",
      method: "GET",
      requestUri: cmnP.encodePath`/2019-09-25/functions/${params["FunctionName"]}/event-invoke-config/list`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FunctionEventInvokeConfigs": [toFunctionEventInvokeConfig],
        "NextMarker": "s",
      },
    }, await resp.json());
  }

  async listFunctions(
    params: s.ListFunctionsRequest = {},
  ): Promise<s.ListFunctionsResponse> {
    const query = new URLSearchParams;
    if (params["MasterRegion"] != null) query.set("MasterRegion", params["MasterRegion"]?.toString() ?? "");
    if (params["FunctionVersion"] != null) query.set("FunctionVersion", params["FunctionVersion"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListFunctions",
      method: "GET",
      requestUri: "/2015-03-31/functions/",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "Functions": [toFunctionConfiguration],
      },
    }, await resp.json());
  }

  async listFunctionsByCodeSigningConfig(
    params: s.ListFunctionsByCodeSigningConfigRequest,
  ): Promise<s.ListFunctionsByCodeSigningConfigResponse> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListFunctionsByCodeSigningConfig",
      method: "GET",
      requestUri: cmnP.encodePath`/2020-04-22/code-signing-configs/${params["CodeSigningConfigArn"]}/functions`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "FunctionArns": ["s"],
      },
    }, await resp.json());
  }

  async listLayerVersions(
    params: s.ListLayerVersionsRequest,
  ): Promise<s.ListLayerVersionsResponse> {
    const query = new URLSearchParams;
    if (params["CompatibleRuntime"] != null) query.set("CompatibleRuntime", params["CompatibleRuntime"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListLayerVersions",
      method: "GET",
      requestUri: cmnP.encodePath`/2018-10-31/layers/${params["LayerName"]}/versions`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "LayerVersions": [toLayerVersionsListItem],
      },
    }, await resp.json());
  }

  async listLayers(
    params: s.ListLayersRequest = {},
  ): Promise<s.ListLayersResponse> {
    const query = new URLSearchParams;
    if (params["CompatibleRuntime"] != null) query.set("CompatibleRuntime", params["CompatibleRuntime"]?.toString() ?? "");
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListLayers",
      method: "GET",
      requestUri: "/2018-10-31/layers",
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "Layers": [toLayersListItem],
      },
    }, await resp.json());
  }

  async listProvisionedConcurrencyConfigs(
    params: s.ListProvisionedConcurrencyConfigsRequest,
  ): Promise<s.ListProvisionedConcurrencyConfigsResponse> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListProvisionedConcurrencyConfigs",
      method: "GET",
      requestUri: cmnP.encodePath`/2019-09-30/functions/${params["FunctionName"]}/provisioned-concurrency?List=ALL`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ProvisionedConcurrencyConfigs": [toProvisionedConcurrencyConfigListItem],
        "NextMarker": "s",
      },
    }, await resp.json());
  }

  async listTags(
    params: s.ListTagsRequest,
  ): Promise<s.ListTagsResponse> {

    const resp = await this.#client.performRequest({
      action: "ListTags",
      method: "GET",
      requestUri: cmnP.encodePath`/2017-03-31/tags/${params["Resource"]}`,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Tags": x => jsonP.readMap(String, String, x),
      },
    }, await resp.json());
  }

  async listVersionsByFunction(
    params: s.ListVersionsByFunctionRequest,
  ): Promise<s.ListVersionsByFunctionResponse> {
    const query = new URLSearchParams;
    if (params["Marker"] != null) query.set("Marker", params["Marker"]?.toString() ?? "");
    if (params["MaxItems"] != null) query.set("MaxItems", params["MaxItems"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "ListVersionsByFunction",
      method: "GET",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/versions`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "NextMarker": "s",
        "Versions": [toFunctionConfiguration],
      },
    }, await resp.json());
  }

  async publishLayerVersion(
    params: s.PublishLayerVersionRequest,
  ): Promise<s.PublishLayerVersionResponse> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
      Content: fromLayerVersionContentInput(params["Content"]),
      CompatibleRuntimes: params["CompatibleRuntimes"],
      LicenseInfo: params["LicenseInfo"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "PublishLayerVersion",
      requestUri: cmnP.encodePath`/2018-10-31/layers/${params["LayerName"]}/versions`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "Content": toLayerVersionContentOutput,
        "LayerArn": "s",
        "LayerVersionArn": "s",
        "Description": "s",
        "CreatedDate": "s",
        "Version": "n",
        "CompatibleRuntimes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Runtime>(x)],
        "LicenseInfo": "s",
      },
    }, await resp.json());
  }

  async publishVersion(
    params: s.PublishVersionRequest,
  ): Promise<s.FunctionConfiguration> {
    const body: jsonP.JSONObject = {
      CodeSha256: params["CodeSha256"],
      Description: params["Description"],
      RevisionId: params["RevisionId"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "PublishVersion",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/versions`,
      responseCode: 201,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FunctionName": "s",
        "FunctionArn": "s",
        "Runtime": (x: jsonP.JSONValue) => cmnP.readEnum<s.Runtime>(x),
        "Role": "s",
        "Handler": "s",
        "CodeSize": "n",
        "Description": "s",
        "Timeout": "n",
        "MemorySize": "n",
        "LastModified": "s",
        "CodeSha256": "s",
        "Version": "s",
        "VpcConfig": toVpcConfigResponse,
        "DeadLetterConfig": toDeadLetterConfig,
        "Environment": toEnvironmentResponse,
        "KMSKeyArn": "s",
        "TracingConfig": toTracingConfigResponse,
        "MasterArn": "s",
        "RevisionId": "s",
        "Layers": [toLayer],
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.State>(x),
        "StateReason": "s",
        "StateReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.StateReasonCode>(x),
        "LastUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.LastUpdateStatus>(x),
        "LastUpdateStatusReason": "s",
        "LastUpdateStatusReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LastUpdateStatusReasonCode>(x),
        "FileSystemConfigs": [toFileSystemConfig],
        "PackageType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageType>(x),
        "ImageConfigResponse": toImageConfigResponse,
        "SigningProfileVersionArn": "s",
        "SigningJobArn": "s",
      },
    }, await resp.json());
  }

  async putFunctionCodeSigningConfig(
    params: s.PutFunctionCodeSigningConfigRequest,
  ): Promise<s.PutFunctionCodeSigningConfigResponse> {
    const body: jsonP.JSONObject = {
      CodeSigningConfigArn: params["CodeSigningConfigArn"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "PutFunctionCodeSigningConfig",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-06-30/functions/${params["FunctionName"]}/code-signing-config`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "CodeSigningConfigArn": "s",
        "FunctionName": "s",
      },
      optional: {},
    }, await resp.json());
  }

  async putFunctionConcurrency(
    params: s.PutFunctionConcurrencyRequest,
  ): Promise<s.Concurrency> {
    const body: jsonP.JSONObject = {
      ReservedConcurrentExecutions: params["ReservedConcurrentExecutions"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "PutFunctionConcurrency",
      method: "PUT",
      requestUri: cmnP.encodePath`/2017-10-31/functions/${params["FunctionName"]}/concurrency`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "ReservedConcurrentExecutions": "n",
      },
    }, await resp.json());
  }

  async putFunctionEventInvokeConfig(
    params: s.PutFunctionEventInvokeConfigRequest,
  ): Promise<s.FunctionEventInvokeConfig> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      MaximumRetryAttempts: params["MaximumRetryAttempts"],
      MaximumEventAgeInSeconds: params["MaximumEventAgeInSeconds"],
      DestinationConfig: fromDestinationConfig(params["DestinationConfig"]),
    };
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query, body,
      action: "PutFunctionEventInvokeConfig",
      method: "PUT",
      requestUri: cmnP.encodePath`/2019-09-25/functions/${params["FunctionName"]}/event-invoke-config`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LastModified": "d",
        "FunctionArn": "s",
        "MaximumRetryAttempts": "n",
        "MaximumEventAgeInSeconds": "n",
        "DestinationConfig": toDestinationConfig,
      },
    }, await resp.json());
  }

  async putProvisionedConcurrencyConfig(
    params: s.PutProvisionedConcurrencyConfigRequest,
  ): Promise<s.PutProvisionedConcurrencyConfigResponse> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      ProvisionedConcurrentExecutions: params["ProvisionedConcurrentExecutions"],
    };
    query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query, body,
      action: "PutProvisionedConcurrencyConfig",
      method: "PUT",
      requestUri: cmnP.encodePath`/2019-09-30/functions/${params["FunctionName"]}/provisioned-concurrency`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "RequestedProvisionedConcurrentExecutions": "n",
        "AvailableProvisionedConcurrentExecutions": "n",
        "AllocatedProvisionedConcurrentExecutions": "n",
        "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProvisionedConcurrencyStatusEnum>(x),
        "StatusReason": "s",
        "LastModified": "s",
      },
    }, await resp.json());
  }

  async removeLayerVersionPermission(
    params: s.RemoveLayerVersionPermissionRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["RevisionId"] != null) query.set("RevisionId", params["RevisionId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "RemoveLayerVersionPermission",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2018-10-31/layers/${params["LayerName"]}/versions/${params["VersionNumber"].toString()}/policy/${params["StatementId"]}`,
      responseCode: 204,
    });
  }

  async removePermission(
    params: s.RemovePermissionRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    if (params["RevisionId"] != null) query.set("RevisionId", params["RevisionId"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query,
      action: "RemovePermission",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/policy/${params["StatementId"]}`,
      responseCode: 204,
    });
  }

  async tagResource(
    params: s.TagResourceRequest,
  ): Promise<void> {
    const body: jsonP.JSONObject = {
      Tags: params["Tags"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "TagResource",
      requestUri: cmnP.encodePath`/2017-03-31/tags/${params["Resource"]}`,
      responseCode: 204,
    });
  }

  async untagResource(
    params: s.UntagResourceRequest,
  ): Promise<void> {
    const query = new URLSearchParams;
    for (const item of params["TagKeys"]) {
      query.append("tagKeys", item?.toString() ?? "");
    }
    const resp = await this.#client.performRequest({
      query,
      action: "UntagResource",
      method: "DELETE",
      requestUri: cmnP.encodePath`/2017-03-31/tags/${params["Resource"]}`,
      responseCode: 204,
    });
  }

  async updateAlias(
    params: s.UpdateAliasRequest,
  ): Promise<s.AliasConfiguration> {
    const body: jsonP.JSONObject = {
      FunctionVersion: params["FunctionVersion"],
      Description: params["Description"],
      RoutingConfig: fromAliasRoutingConfiguration(params["RoutingConfig"]),
      RevisionId: params["RevisionId"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "UpdateAlias",
      method: "PUT",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/aliases/${params["Name"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "AliasArn": "s",
        "Name": "s",
        "FunctionVersion": "s",
        "Description": "s",
        "RoutingConfig": toAliasRoutingConfiguration,
        "RevisionId": "s",
      },
    }, await resp.json());
  }

  async updateCodeSigningConfig(
    params: s.UpdateCodeSigningConfigRequest,
  ): Promise<s.UpdateCodeSigningConfigResponse> {
    const body: jsonP.JSONObject = {
      Description: params["Description"],
      AllowedPublishers: fromAllowedPublishers(params["AllowedPublishers"]),
      CodeSigningPolicies: fromCodeSigningPolicies(params["CodeSigningPolicies"]),
    };
    const resp = await this.#client.performRequest({
      body,
      action: "UpdateCodeSigningConfig",
      method: "PUT",
      requestUri: cmnP.encodePath`/2020-04-22/code-signing-configs/${params["CodeSigningConfigArn"]}`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {
        "CodeSigningConfig": toCodeSigningConfig,
      },
      optional: {},
    }, await resp.json());
  }

  async updateEventSourceMapping(
    params: s.UpdateEventSourceMappingRequest,
  ): Promise<s.EventSourceMappingConfiguration> {
    const body: jsonP.JSONObject = {
      FunctionName: params["FunctionName"],
      Enabled: params["Enabled"],
      BatchSize: params["BatchSize"],
      MaximumBatchingWindowInSeconds: params["MaximumBatchingWindowInSeconds"],
      DestinationConfig: fromDestinationConfig(params["DestinationConfig"]),
      MaximumRecordAgeInSeconds: params["MaximumRecordAgeInSeconds"],
      BisectBatchOnFunctionError: params["BisectBatchOnFunctionError"],
      MaximumRetryAttempts: params["MaximumRetryAttempts"],
      ParallelizationFactor: params["ParallelizationFactor"],
      SourceAccessConfigurations: params["SourceAccessConfigurations"]?.map(x => fromSourceAccessConfiguration(x)),
      TumblingWindowInSeconds: params["TumblingWindowInSeconds"],
      FunctionResponseTypes: params["FunctionResponseTypes"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "UpdateEventSourceMapping",
      method: "PUT",
      requestUri: cmnP.encodePath`/2015-03-31/event-source-mappings/${params["UUID"]}`,
      responseCode: 202,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "UUID": "s",
        "StartingPosition": (x: jsonP.JSONValue) => cmnP.readEnum<s.EventSourcePosition>(x),
        "StartingPositionTimestamp": "d",
        "BatchSize": "n",
        "MaximumBatchingWindowInSeconds": "n",
        "ParallelizationFactor": "n",
        "EventSourceArn": "s",
        "FunctionArn": "s",
        "LastModified": "d",
        "LastProcessingResult": "s",
        "State": "s",
        "StateTransitionReason": "s",
        "DestinationConfig": toDestinationConfig,
        "Topics": ["s"],
        "Queues": ["s"],
        "SourceAccessConfigurations": [toSourceAccessConfiguration],
        "SelfManagedEventSource": toSelfManagedEventSource,
        "MaximumRecordAgeInSeconds": "n",
        "BisectBatchOnFunctionError": "b",
        "MaximumRetryAttempts": "n",
        "TumblingWindowInSeconds": "n",
        "FunctionResponseTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.FunctionResponseType>(x)],
      },
    }, await resp.json());
  }

  async updateFunctionCode(
    params: s.UpdateFunctionCodeRequest,
  ): Promise<s.FunctionConfiguration> {
    const body: jsonP.JSONObject = {
      ZipFile: serializeBlob(params["ZipFile"]),
      S3Bucket: params["S3Bucket"],
      S3Key: params["S3Key"],
      S3ObjectVersion: params["S3ObjectVersion"],
      ImageUri: params["ImageUri"],
      Publish: params["Publish"],
      DryRun: params["DryRun"],
      RevisionId: params["RevisionId"],
    };
    const resp = await this.#client.performRequest({
      body,
      action: "UpdateFunctionCode",
      method: "PUT",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/code`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FunctionName": "s",
        "FunctionArn": "s",
        "Runtime": (x: jsonP.JSONValue) => cmnP.readEnum<s.Runtime>(x),
        "Role": "s",
        "Handler": "s",
        "CodeSize": "n",
        "Description": "s",
        "Timeout": "n",
        "MemorySize": "n",
        "LastModified": "s",
        "CodeSha256": "s",
        "Version": "s",
        "VpcConfig": toVpcConfigResponse,
        "DeadLetterConfig": toDeadLetterConfig,
        "Environment": toEnvironmentResponse,
        "KMSKeyArn": "s",
        "TracingConfig": toTracingConfigResponse,
        "MasterArn": "s",
        "RevisionId": "s",
        "Layers": [toLayer],
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.State>(x),
        "StateReason": "s",
        "StateReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.StateReasonCode>(x),
        "LastUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.LastUpdateStatus>(x),
        "LastUpdateStatusReason": "s",
        "LastUpdateStatusReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LastUpdateStatusReasonCode>(x),
        "FileSystemConfigs": [toFileSystemConfig],
        "PackageType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageType>(x),
        "ImageConfigResponse": toImageConfigResponse,
        "SigningProfileVersionArn": "s",
        "SigningJobArn": "s",
      },
    }, await resp.json());
  }

  async updateFunctionConfiguration(
    params: s.UpdateFunctionConfigurationRequest,
  ): Promise<s.FunctionConfiguration> {
    const body: jsonP.JSONObject = {
      Role: params["Role"],
      Handler: params["Handler"],
      Description: params["Description"],
      Timeout: params["Timeout"],
      MemorySize: params["MemorySize"],
      VpcConfig: fromVpcConfig(params["VpcConfig"]),
      Environment: fromEnvironment(params["Environment"]),
      Runtime: params["Runtime"],
      DeadLetterConfig: fromDeadLetterConfig(params["DeadLetterConfig"]),
      KMSKeyArn: params["KMSKeyArn"],
      TracingConfig: fromTracingConfig(params["TracingConfig"]),
      RevisionId: params["RevisionId"],
      Layers: params["Layers"],
      FileSystemConfigs: params["FileSystemConfigs"]?.map(x => fromFileSystemConfig(x)),
      ImageConfig: fromImageConfig(params["ImageConfig"]),
    };
    const resp = await this.#client.performRequest({
      body,
      action: "UpdateFunctionConfiguration",
      method: "PUT",
      requestUri: cmnP.encodePath`/2015-03-31/functions/${params["FunctionName"]}/configuration`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "FunctionName": "s",
        "FunctionArn": "s",
        "Runtime": (x: jsonP.JSONValue) => cmnP.readEnum<s.Runtime>(x),
        "Role": "s",
        "Handler": "s",
        "CodeSize": "n",
        "Description": "s",
        "Timeout": "n",
        "MemorySize": "n",
        "LastModified": "s",
        "CodeSha256": "s",
        "Version": "s",
        "VpcConfig": toVpcConfigResponse,
        "DeadLetterConfig": toDeadLetterConfig,
        "Environment": toEnvironmentResponse,
        "KMSKeyArn": "s",
        "TracingConfig": toTracingConfigResponse,
        "MasterArn": "s",
        "RevisionId": "s",
        "Layers": [toLayer],
        "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.State>(x),
        "StateReason": "s",
        "StateReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.StateReasonCode>(x),
        "LastUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.LastUpdateStatus>(x),
        "LastUpdateStatusReason": "s",
        "LastUpdateStatusReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LastUpdateStatusReasonCode>(x),
        "FileSystemConfigs": [toFileSystemConfig],
        "PackageType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageType>(x),
        "ImageConfigResponse": toImageConfigResponse,
        "SigningProfileVersionArn": "s",
        "SigningJobArn": "s",
      },
    }, await resp.json());
  }

  async updateFunctionEventInvokeConfig(
    params: s.UpdateFunctionEventInvokeConfigRequest,
  ): Promise<s.FunctionEventInvokeConfig> {
    const query = new URLSearchParams;
    const body: jsonP.JSONObject = {
      MaximumRetryAttempts: params["MaximumRetryAttempts"],
      MaximumEventAgeInSeconds: params["MaximumEventAgeInSeconds"],
      DestinationConfig: fromDestinationConfig(params["DestinationConfig"]),
    };
    if (params["Qualifier"] != null) query.set("Qualifier", params["Qualifier"]?.toString() ?? "");
    const resp = await this.#client.performRequest({
      query, body,
      action: "UpdateFunctionEventInvokeConfig",
      requestUri: cmnP.encodePath`/2019-09-25/functions/${params["FunctionName"]}/event-invoke-config`,
      responseCode: 200,
    });
    return jsonP.readObj({
      required: {},
      optional: {
        "LastModified": "d",
        "FunctionArn": "s",
        "MaximumRetryAttempts": "n",
        "MaximumEventAgeInSeconds": "n",
        "DestinationConfig": toDestinationConfig,
      },
    }, await resp.json());
  }

  // Resource State Waiters

  /** Checks state up to 20 times, 1 seconds apart (about 1 minutes max wait time). */
  async waitForFunctionExists(
    params: s.GetFunctionRequest,
  ): Promise<s.GetFunctionResponse> {
    const errMessage = 'ResourceNotReady: Resource is not in the state FunctionExists';
    for (let i = 0; i < 20; i++) {
      try {
        const resp = await this.getFunction(params);
        return resp; // for status 200
      } catch (err) {
        if (!["ResourceNotFoundException"].includes(err.shortCode)) throw err;
      }
      await new Promise(r => setTimeout(r, 1000));
    }
    throw new Error(errMessage);
  }

  /**
   * Waits for the function's State to be Active.
   * Checks state up to 60 times, 5 seconds apart (about 5 minutes max wait time).
   */
  async waitForFunctionActive(
    params: s.GetFunctionConfigurationRequest,
  ): Promise<s.FunctionConfiguration> {
    const errMessage = 'ResourceNotReady: Resource is not in the state FunctionActive';
    for (let i = 0; i < 60; i++) {
      const resp = await this.getFunctionConfiguration(params);
      const field = resp?.State;
      if (field === "Active") return resp;
      if (field === "Failed") throw new Error(errMessage);
      if (field === "Pending") continue;
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

  /**
   * Waits for the function's LastUpdateStatus to be Successful.
   * Checks state up to 60 times, 5 seconds apart (about 5 minutes max wait time).
   */
  async waitForFunctionUpdated(
    params: s.GetFunctionConfigurationRequest,
  ): Promise<s.FunctionConfiguration> {
    const errMessage = 'ResourceNotReady: Resource is not in the state FunctionUpdated';
    for (let i = 0; i < 60; i++) {
      const resp = await this.getFunctionConfiguration(params);
      const field = resp?.LastUpdateStatus;
      if (field === "Successful") return resp;
      if (field === "Failed") throw new Error(errMessage);
      if (field === "InProgress") continue;
      await new Promise(r => setTimeout(r, 5000));
    }
    throw new Error(errMessage);
  }

}

function toAliasConfiguration(root: jsonP.JSONValue): s.AliasConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "AliasArn": "s",
      "Name": "s",
      "FunctionVersion": "s",
      "Description": "s",
      "RoutingConfig": toAliasRoutingConfiguration,
      "RevisionId": "s",
    },
  }, root);
}

function toEventSourceMappingConfiguration(root: jsonP.JSONValue): s.EventSourceMappingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "UUID": "s",
      "StartingPosition": (x: jsonP.JSONValue) => cmnP.readEnum<s.EventSourcePosition>(x),
      "StartingPositionTimestamp": "d",
      "BatchSize": "n",
      "MaximumBatchingWindowInSeconds": "n",
      "ParallelizationFactor": "n",
      "EventSourceArn": "s",
      "FunctionArn": "s",
      "LastModified": "d",
      "LastProcessingResult": "s",
      "State": "s",
      "StateTransitionReason": "s",
      "DestinationConfig": toDestinationConfig,
      "Topics": ["s"],
      "Queues": ["s"],
      "SourceAccessConfigurations": [toSourceAccessConfiguration],
      "SelfManagedEventSource": toSelfManagedEventSource,
      "MaximumRecordAgeInSeconds": "n",
      "BisectBatchOnFunctionError": "b",
      "MaximumRetryAttempts": "n",
      "TumblingWindowInSeconds": "n",
      "FunctionResponseTypes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.FunctionResponseType>(x)],
    },
  }, root);
}

function toFunctionConfiguration(root: jsonP.JSONValue): s.FunctionConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "FunctionName": "s",
      "FunctionArn": "s",
      "Runtime": (x: jsonP.JSONValue) => cmnP.readEnum<s.Runtime>(x),
      "Role": "s",
      "Handler": "s",
      "CodeSize": "n",
      "Description": "s",
      "Timeout": "n",
      "MemorySize": "n",
      "LastModified": "s",
      "CodeSha256": "s",
      "Version": "s",
      "VpcConfig": toVpcConfigResponse,
      "DeadLetterConfig": toDeadLetterConfig,
      "Environment": toEnvironmentResponse,
      "KMSKeyArn": "s",
      "TracingConfig": toTracingConfigResponse,
      "MasterArn": "s",
      "RevisionId": "s",
      "Layers": [toLayer],
      "State": (x: jsonP.JSONValue) => cmnP.readEnum<s.State>(x),
      "StateReason": "s",
      "StateReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.StateReasonCode>(x),
      "LastUpdateStatus": (x: jsonP.JSONValue) => cmnP.readEnum<s.LastUpdateStatus>(x),
      "LastUpdateStatusReason": "s",
      "LastUpdateStatusReasonCode": (x: jsonP.JSONValue) => cmnP.readEnum<s.LastUpdateStatusReasonCode>(x),
      "FileSystemConfigs": [toFileSystemConfig],
      "PackageType": (x: jsonP.JSONValue) => cmnP.readEnum<s.PackageType>(x),
      "ImageConfigResponse": toImageConfigResponse,
      "SigningProfileVersionArn": "s",
      "SigningJobArn": "s",
    },
  }, root);
}

function toFunctionEventInvokeConfig(root: jsonP.JSONValue): s.FunctionEventInvokeConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "LastModified": "d",
      "FunctionArn": "s",
      "MaximumRetryAttempts": "n",
      "MaximumEventAgeInSeconds": "n",
      "DestinationConfig": toDestinationConfig,
    },
  }, root);
}

function toConcurrency(root: jsonP.JSONValue): s.Concurrency {
  return jsonP.readObj({
    required: {},
    optional: {
      "ReservedConcurrentExecutions": "n",
    },
  }, root);
}

function fromAliasRoutingConfiguration(input?: s.AliasRoutingConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    AdditionalVersionWeights: input["AdditionalVersionWeights"],
  }
}
function toAliasRoutingConfiguration(root: jsonP.JSONValue): s.AliasRoutingConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "AdditionalVersionWeights": x => jsonP.readMap(String, Number, x),
    },
  }, root);
}

function fromAllowedPublishers(input?: s.AllowedPublishers | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SigningProfileVersionArns: input["SigningProfileVersionArns"],
  }
}
function toAllowedPublishers(root: jsonP.JSONValue): s.AllowedPublishers {
  return jsonP.readObj({
    required: {
      "SigningProfileVersionArns": ["s"],
    },
    optional: {},
  }, root);
}

function fromCodeSigningPolicies(input?: s.CodeSigningPolicies | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    UntrustedArtifactOnDeployment: input["UntrustedArtifactOnDeployment"],
  }
}
function toCodeSigningPolicies(root: jsonP.JSONValue): s.CodeSigningPolicies {
  return jsonP.readObj({
    required: {},
    optional: {
      "UntrustedArtifactOnDeployment": (x: jsonP.JSONValue) => cmnP.readEnum<s.CodeSigningPolicy>(x),
    },
  }, root);
}

function fromDestinationConfig(input?: s.DestinationConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    OnSuccess: fromOnSuccess(input["OnSuccess"]),
    OnFailure: fromOnFailure(input["OnFailure"]),
  }
}
function toDestinationConfig(root: jsonP.JSONValue): s.DestinationConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "OnSuccess": toOnSuccess,
      "OnFailure": toOnFailure,
    },
  }, root);
}

function fromOnSuccess(input?: s.OnSuccess | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Destination: input["Destination"],
  }
}
function toOnSuccess(root: jsonP.JSONValue): s.OnSuccess {
  return jsonP.readObj({
    required: {},
    optional: {
      "Destination": "s",
    },
  }, root);
}

function fromOnFailure(input?: s.OnFailure | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Destination: input["Destination"],
  }
}
function toOnFailure(root: jsonP.JSONValue): s.OnFailure {
  return jsonP.readObj({
    required: {},
    optional: {
      "Destination": "s",
    },
  }, root);
}

function fromSourceAccessConfiguration(input?: s.SourceAccessConfiguration | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Type: input["Type"],
    URI: input["URI"],
  }
}
function toSourceAccessConfiguration(root: jsonP.JSONValue): s.SourceAccessConfiguration {
  return jsonP.readObj({
    required: {},
    optional: {
      "Type": (x: jsonP.JSONValue) => cmnP.readEnum<s.SourceAccessType>(x),
      "URI": "s",
    },
  }, root);
}

function fromSelfManagedEventSource(input?: s.SelfManagedEventSource | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Endpoints: input["Endpoints"],
  }
}
function toSelfManagedEventSource(root: jsonP.JSONValue): s.SelfManagedEventSource {
  return jsonP.readObj({
    required: {},
    optional: {
      "Endpoints": x => jsonP.readMap(x => cmnP.readEnumReq<s.EndPointType>(x), l => Array.isArray(l) ? l.map(String) : [], x),
    },
  }, root);
}

function fromFunctionCode(input?: s.FunctionCode | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    ZipFile: serializeBlob(input["ZipFile"]),
    S3Bucket: input["S3Bucket"],
    S3Key: input["S3Key"],
    S3ObjectVersion: input["S3ObjectVersion"],
    ImageUri: input["ImageUri"],
  }
}

function fromVpcConfig(input?: s.VpcConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    SubnetIds: input["SubnetIds"],
    SecurityGroupIds: input["SecurityGroupIds"],
  }
}

function fromDeadLetterConfig(input?: s.DeadLetterConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    TargetArn: input["TargetArn"],
  }
}
function toDeadLetterConfig(root: jsonP.JSONValue): s.DeadLetterConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "TargetArn": "s",
    },
  }, root);
}

function fromEnvironment(input?: s.Environment | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Variables: input["Variables"],
  }
}

function fromTracingConfig(input?: s.TracingConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Mode: input["Mode"],
  }
}

function fromFileSystemConfig(input?: s.FileSystemConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    Arn: input["Arn"],
    LocalMountPath: input["LocalMountPath"],
  }
}
function toFileSystemConfig(root: jsonP.JSONValue): s.FileSystemConfig {
  return jsonP.readObj({
    required: {
      "Arn": "s",
      "LocalMountPath": "s",
    },
    optional: {},
  }, root);
}

function fromImageConfig(input?: s.ImageConfig | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    EntryPoint: input["EntryPoint"],
    Command: input["Command"],
    WorkingDirectory: input["WorkingDirectory"],
  }
}
function toImageConfig(root: jsonP.JSONValue): s.ImageConfig {
  return jsonP.readObj({
    required: {},
    optional: {
      "EntryPoint": ["s"],
      "Command": ["s"],
      "WorkingDirectory": "s",
    },
  }, root);
}

function fromLayerVersionContentInput(input?: s.LayerVersionContentInput | null): jsonP.JSONValue {
  if (!input) return input;
  return {
    S3Bucket: input["S3Bucket"],
    S3Key: input["S3Key"],
    S3ObjectVersion: input["S3ObjectVersion"],
    ZipFile: serializeBlob(input["ZipFile"]),
  }
}

function toCodeSigningConfig(root: jsonP.JSONValue): s.CodeSigningConfig {
  return jsonP.readObj({
    required: {
      "CodeSigningConfigId": "s",
      "CodeSigningConfigArn": "s",
      "AllowedPublishers": toAllowedPublishers,
      "CodeSigningPolicies": toCodeSigningPolicies,
      "LastModified": "s",
    },
    optional: {
      "Description": "s",
    },
  }, root);
}

function toVpcConfigResponse(root: jsonP.JSONValue): s.VpcConfigResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "SubnetIds": ["s"],
      "SecurityGroupIds": ["s"],
      "VpcId": "s",
    },
  }, root);
}

function toEnvironmentResponse(root: jsonP.JSONValue): s.EnvironmentResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Variables": x => jsonP.readMap(String, String, x),
      "Error": toEnvironmentError,
    },
  }, root);
}

function toEnvironmentError(root: jsonP.JSONValue): s.EnvironmentError {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": "s",
      "Message": "s",
    },
  }, root);
}

function toTracingConfigResponse(root: jsonP.JSONValue): s.TracingConfigResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "Mode": (x: jsonP.JSONValue) => cmnP.readEnum<s.TracingMode>(x),
    },
  }, root);
}

function toLayer(root: jsonP.JSONValue): s.Layer {
  return jsonP.readObj({
    required: {},
    optional: {
      "Arn": "s",
      "CodeSize": "n",
      "SigningProfileVersionArn": "s",
      "SigningJobArn": "s",
    },
  }, root);
}

function toImageConfigResponse(root: jsonP.JSONValue): s.ImageConfigResponse {
  return jsonP.readObj({
    required: {},
    optional: {
      "ImageConfig": toImageConfig,
      "Error": toImageConfigError,
    },
  }, root);
}

function toImageConfigError(root: jsonP.JSONValue): s.ImageConfigError {
  return jsonP.readObj({
    required: {},
    optional: {
      "ErrorCode": "s",
      "Message": "s",
    },
  }, root);
}

function toAccountLimit(root: jsonP.JSONValue): s.AccountLimit {
  return jsonP.readObj({
    required: {},
    optional: {
      "TotalCodeSize": "n",
      "CodeSizeUnzipped": "n",
      "CodeSizeZipped": "n",
      "ConcurrentExecutions": "n",
      "UnreservedConcurrentExecutions": "n",
    },
  }, root);
}

function toAccountUsage(root: jsonP.JSONValue): s.AccountUsage {
  return jsonP.readObj({
    required: {},
    optional: {
      "TotalCodeSize": "n",
      "FunctionCount": "n",
    },
  }, root);
}

function toFunctionCodeLocation(root: jsonP.JSONValue): s.FunctionCodeLocation {
  return jsonP.readObj({
    required: {},
    optional: {
      "RepositoryType": "s",
      "Location": "s",
      "ImageUri": "s",
      "ResolvedImageUri": "s",
    },
  }, root);
}

function toLayerVersionContentOutput(root: jsonP.JSONValue): s.LayerVersionContentOutput {
  return jsonP.readObj({
    required: {},
    optional: {
      "Location": "s",
      "CodeSha256": "s",
      "CodeSize": "n",
      "SigningProfileVersionArn": "s",
      "SigningJobArn": "s",
    },
  }, root);
}

function toLayerVersionsListItem(root: jsonP.JSONValue): s.LayerVersionsListItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "LayerVersionArn": "s",
      "Version": "n",
      "Description": "s",
      "CreatedDate": "s",
      "CompatibleRuntimes": [(x: jsonP.JSONValue) => cmnP.readEnum<s.Runtime>(x)],
      "LicenseInfo": "s",
    },
  }, root);
}

function toLayersListItem(root: jsonP.JSONValue): s.LayersListItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "LayerName": "s",
      "LayerArn": "s",
      "LatestMatchingVersion": toLayerVersionsListItem,
    },
  }, root);
}

function toProvisionedConcurrencyConfigListItem(root: jsonP.JSONValue): s.ProvisionedConcurrencyConfigListItem {
  return jsonP.readObj({
    required: {},
    optional: {
      "FunctionArn": "s",
      "RequestedProvisionedConcurrentExecutions": "n",
      "AvailableProvisionedConcurrentExecutions": "n",
      "AllocatedProvisionedConcurrentExecutions": "n",
      "Status": (x: jsonP.JSONValue) => cmnP.readEnum<s.ProvisionedConcurrencyStatusEnum>(x),
      "StatusReason": "s",
      "LastModified": "s",
    },
  }, root);
}
